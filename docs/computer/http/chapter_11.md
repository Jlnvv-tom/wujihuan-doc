# ç¬¬åä¸€ç« ï¼šå®é™…åº”ç”¨åœºæ™¯ä¸æœ€ä½³å®è·µ

## ğŸ“‹ æ–‡ç« æ‘˜è¦

æœ¬ç« æ·±å…¥æ¢è®¨ç½‘ç»œæŠ€æœ¯åœ¨å„ä¸ªå®é™…åº”ç”¨åœºæ™¯ä¸­çš„æœ€ä½³å®è·µï¼Œæ¶µç›–ä¼ä¸šç½‘ç»œæ¶æ„è®¾è®¡ã€äº‘åŸç”Ÿåº”ç”¨ç½‘ç»œä¼˜åŒ–ã€ç§»åŠ¨åº”ç”¨ç½‘ç»œä¼˜åŒ–ã€ç‰©è”ç½‘IoTç½‘ç»œåè®®ã€æ¸¸æˆç½‘ç»œæ¶æ„ä»¥åŠé‡‘èè¡Œä¸šç½‘ç»œå®è·µã€‚é€šè¿‡ä¸°å¯Œçš„Goè¯­è¨€å®æˆ˜ä»£ç ç¤ºä¾‹ï¼Œè¯¦ç»†å±•ç¤ºå¦‚ä½•åœ¨ä¸åŒåœºæ™¯ä¸­åº”ç”¨ç½‘ç»œæŠ€æœ¯å®ç°é«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€å®‰å…¨å¯é çš„ç½‘ç»œè§£å†³æ–¹æ¡ˆã€‚æœ¬ç« å°†ä¸ºç½‘ç»œå·¥ç¨‹å¸ˆã€ç³»ç»Ÿæ¶æ„å¸ˆå’ŒWebå¼€å‘è€…æä¾›å®è´µçš„å®æˆ˜ç»éªŒå’ŒæŠ€æœ¯æŒ‡å¯¼ã€‚

**å…³é”®è¯**ï¼šä¼ä¸šç½‘ç»œã€äº‘åŸç”Ÿæ¶æ„ã€ç§»åŠ¨ä¼˜åŒ–ã€ç‰©è”ç½‘ã€æ¸¸æˆç½‘ç»œã€é‡‘èå®‰å…¨ã€Goè¯­è¨€å®æˆ˜

## ğŸ“Š å­—æ•°ç»Ÿè®¡

ç›®æ ‡å­—æ•°ï¼š8000-15000å­—

---

## ğŸš€ å¼•è¨€

### èƒŒæ™¯ä»‹ç»

éšç€äº’è”ç½‘æŠ€æœ¯çš„å¿«é€Ÿå‘å±•å’Œæ•°å­—åŒ–è½¬å‹çš„æ·±å…¥æ¨è¿›ï¼Œç½‘ç»œæŠ€æœ¯å·²å¹¿æ³›åº”ç”¨äºå„ä¸ªè¡Œä¸šå’Œåœºæ™¯ã€‚ä»ä¼ ç»Ÿçš„ä¼ä¸šç½‘ç»œåˆ°æ–°å…´çš„äº‘åŸç”Ÿæ¶æ„ï¼Œä»ç§»åŠ¨åº”ç”¨ä¼˜åŒ–åˆ°ç‰©è”ç½‘ç½‘ç»œåè®®ï¼Œä»å®æ—¶æ¸¸æˆæ¶æ„åˆ°é‡‘èå®‰å…¨å®è·µï¼Œä¸åŒåœºæ™¯å¯¹ç½‘ç»œæŠ€æœ¯æå‡ºäº†å·®å¼‚åŒ–çš„éœ€æ±‚å’ŒæŒ‘æˆ˜ã€‚

åœ¨å®é™…åº”ç”¨ä¸­ï¼Œç½‘ç»œæŠ€æœ¯ä¸ä»…è¦è€ƒè™‘åŸºç¡€çš„è¿é€šæ€§å’Œæ€§èƒ½ï¼Œæ›´è¦å…³æ³¨å®‰å…¨æ€§ã€å¯æ‰©å±•æ€§ã€é«˜å¯ç”¨æ€§ç­‰å¤šç»´åº¦çš„è¦æ±‚ã€‚ä¸åŒè¡Œä¸šçš„ä¸šåŠ¡ç‰¹ç‚¹å†³å®šäº†å…¶ç½‘ç»œæ¶æ„çš„ç‰¹æ®Šæ€§ï¼Œè€ŒGoè¯­è¨€ä½œä¸ºç°ä»£ç½‘ç»œç¼–ç¨‹çš„é‡è¦å·¥å…·ï¼Œä¸ºè¿™äº›åœºæ™¯æä¾›äº†å¼ºå¤§çš„æŠ€æœ¯æ”¯æ’‘ã€‚

### å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œè¯»è€…å°†èƒ½å¤Ÿï¼š

1. **æŒæ¡ä¼ä¸šç½‘ç»œæ¶æ„è®¾è®¡**ï¼šç†è§£ç½‘ç»œæ‹“æ‰‘è®¾è®¡ã€å†…å¤–ç½‘åˆ†ç¦»ç­–ç•¥ã€VPNæ¥å…¥æ–¹æ¡ˆå’Œå®‰å…¨é˜²æŠ¤æªæ–½
2. **æ·±å…¥äº‘åŸç”Ÿç½‘ç»œ**ï¼šæŒæ¡å®¹å™¨ç½‘ç»œã€KubernetesæœåŠ¡å‘ç°ã€æœåŠ¡ç½‘æ ¼é€šä¿¡ç­‰æ ¸å¿ƒæŠ€æœ¯
3. **ä¼˜åŒ–ç§»åŠ¨ç½‘ç»œæ€§èƒ½**ï¼šäº†è§£ç§»åŠ¨ç½‘ç»œç‰¹ç‚¹ï¼Œåˆ¶å®šæœ‰æ•ˆçš„ä¼˜åŒ–ç­–ç•¥å’Œç¦»çº¿ç¼“å­˜æ–¹æ¡ˆ
4. **åº”ç”¨IoTç½‘ç»œåè®®**ï¼šç†Ÿæ‚‰IoTæ¶æ„è®¾è®¡ã€MQTT/CoAPåè®®åº”ç”¨å’Œå®‰å…¨è€ƒè™‘
5. **æ„å»ºæ¸¸æˆç½‘ç»œæ¶æ„**ï¼šç†è§£æ¸¸æˆç½‘ç»œéœ€æ±‚ã€å®æ—¶åŒæ­¥æœºåˆ¶å’ŒCDNåŠ é€Ÿç­–ç•¥
6. **å®ç°é‡‘èç½‘ç»œå®‰å…¨**ï¼šæŒæ¡é‡‘èå®‰å…¨è¦æ±‚ã€é«˜å¯ç”¨æ¶æ„è®¾è®¡å’Œåˆè§„æ€§å®è·µ

### æ–‡ç« ç»“æ„

æœ¬ç« æŒ‰ç…§ä»ä¼ ç»Ÿä¼ä¸šç½‘ç»œåˆ°æ–°å…´åº”ç”¨åœºæ™¯çš„é€»è¾‘é¡ºåºå±•å¼€ï¼š

1. **ä¼ä¸šç½‘ç»œæ¶æ„è®¾è®¡**ï¼šä»‹ç»ä¼ ç»Ÿä¼ä¸šç½‘ç»œçš„åŸºç¡€æ¶æ„å’Œæœ€ä½³å®è·µ
2. **äº‘åŸç”Ÿåº”ç”¨ç½‘ç»œ**ï¼šæ¢è®¨ç°ä»£åŒ–äº‘å¹³å°çš„ç½‘ç»œè§£å†³æ–¹æ¡ˆ
3. **ç§»åŠ¨åº”ç”¨ç½‘ç»œä¼˜åŒ–**ï¼šåˆ†æç§»åŠ¨ç½‘ç»œçš„ç‰¹ç‚¹å’Œä¼˜åŒ–æŠ€æœ¯
4. **ç‰©è”ç½‘IoTç½‘ç»œåè®®**ï¼šç ”ç©¶IoTåœºæ™¯ä¸‹çš„ç½‘ç»œåè®®è®¾è®¡
5. **æ¸¸æˆç½‘ç»œæ¶æ„**ï¼šåˆ†æå®æ—¶æ¸¸æˆå¯¹ç½‘ç»œçš„ç‰¹æ®Šéœ€æ±‚
6. **é‡‘èè¡Œä¸šç½‘ç»œå®è·µ**ï¼šä»‹ç»é‡‘èè¡Œä¸šå¯¹ç½‘ç»œå®‰å…¨çš„ä¸¥æ ¼è¦æ±‚

---

## ğŸ¢ ä¼ä¸šç½‘ç»œæ¶æ„è®¾è®¡

### ç½‘ç»œæ‹“æ‰‘è®¾è®¡åŸåˆ™

ä¼ä¸šç½‘ç»œæ‹“æ‰‘è®¾è®¡éœ€è¦ç»¼åˆè€ƒè™‘ä¸šåŠ¡éœ€æ±‚ã€å®‰å…¨è¦æ±‚ã€æˆæœ¬é¢„ç®—å’ŒæŠ€æœ¯å‘å±•è¶‹åŠ¿ã€‚å…¸å‹çš„ä¼ä¸šç½‘ç»œæ‹“æ‰‘åŒ…æ‹¬ï¼š

#### 1. åˆ†å±‚ç½‘ç»œæ¶æ„è®¾è®¡

```go
package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

// NetworkTopology ä¼ä¸šç½‘ç»œæ‹“æ‰‘ç»“æ„
type NetworkTopology struct {
	AccessLayer    []NetworkSegment
	DistributionLayer []NetworkSegment
	CoreLayer      []NetworkSegment
	NetworkID      string
	DesignTime     time.Time
}

// NetworkSegment ç½‘ç»œæ®µå®šä¹‰
type NetworkSegment struct {
	SegmentID   string
	Subnet      *net.IPNet
	Gateway     net.IP
	Description string
	DeviceCount int
	SegmentType string // "access", "distribution", "core"
}

// ä¼ä¸šç½‘ç»œæ‹“æ‰‘ç®¡ç†å™¨
type EnterpriseNetworkManager struct {
	topology *NetworkTopology
	devices  map[string]NetworkDevice
	ctx      context.Context
	cancel   context.CancelFunc
}

// NetworkDevice ç½‘ç»œè®¾å¤‡å®šä¹‰
type NetworkDevice struct {
	DeviceID    string
	DeviceType  string // "switch", "router", "firewall", "load_balancer"
	IPAddress   net.IP
	MACAddress  string
	Status      string
	Uptime      time.Duration
	Bandwidth   int64 // Mbps
	SegmentID   string
}

// åˆ›å»ºä¼ä¸šç½‘ç»œæ‹“æ‰‘
func CreateEnterpriseNetworkTopology() *EnterpriseNetworkManager {
	ctx, cancel := context.WithCancel(context.Background())

	// å®šä¹‰ç½‘ç»œæ®µ
	accessLayer := []NetworkSegment{
		{
			SegmentID:   "ACCESS_1",
			Subnet:      parseCIDR("10.1.1.0/24"),
			Gateway:     net.ParseIP("10.1.1.1"),
			Description: "å‘˜å·¥åŠå…¬åŒºç½‘ç»œæ®µ",
			DeviceCount: 100,
			SegmentType: "access",
		},
		{
			SegmentID:   "ACCESS_2",
			Subnet:      parseCIDR("10.1.2.0/24"),
			Gateway:     net.ParseIP("10.1.2.1"),
			Description: "æœåŠ¡å™¨åŒºç½‘ç»œæ®µ",
			DeviceCount: 50,
			SegmentType: "access",
		},
	}

	distributionLayer := []NetworkSegment{
		{
			SegmentID:   "DIST_1",
			Subnet:      parseCIDR("172.16.1.0/24"),
			Gateway:     net.ParseIP("172.16.1.1"),
			Description: "éƒ¨é—¨æ±‡èšç½‘ç»œæ®µ",
			DeviceCount: 10,
			SegmentType: "distribution",
		},
	}

	coreLayer := []NetworkSegment{
		{
			SegmentID:   "CORE_1",
			Subnet:      parseCIDR("192.168.1.0/24"),
			Gateway:     net.ParseIP("192.168.1.1"),
			Description: "æ ¸å¿ƒäº¤æ¢ç½‘ç»œæ®µ",
			DeviceCount: 5,
			SegmentType: "core",
		},
	}

	topology := &NetworkTopology{
		AccessLayer:    accessLayer,
		DistributionLayer: distributionLayer,
		CoreLayer:      coreLayer,
		NetworkID:      "ENT_001",
		DesignTime:     time.Now(),
	}

	manager := &EnterpriseNetworkManager{
		topology: topology,
		devices:  make(map[string]NetworkDevice),
		ctx:      ctx,
		cancel:   cancel,
	}

	manager.initializeDevices()
	return manager
}

// è§£æCIDRæ ¼å¼çš„IPåœ°å€
func parseCIDR(cidr string) *net.IPNet {
	_, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		log.Fatalf("Invalid CIDR: %v", err)
	}
	return ipNet
}

// åˆå§‹åŒ–ç½‘ç»œè®¾å¤‡
func (enm *EnterpriseNetworkManager) initializeDevices() {
	// åˆå§‹åŒ–æ ¸å¿ƒå±‚è®¾å¤‡
	coreDevices := []NetworkDevice{
		{
			DeviceID:    "CORE_001",
			DeviceType:  "core_switch",
			IPAddress:   net.ParseIP("192.168.1.10"),
			MACAddress:  "00:1B:44:11:3A:B7",
			Status:      "active",
			Uptime:      0,
			Bandwidth:   10000, // 10Gbps
			SegmentID:   "CORE_1",
		},
		{
			DeviceID:    "CORE_002",
			DeviceType:  "core_router",
			IPAddress:   net.ParseIP("192.168.1.1"),
			MACAddress:  "00:1B:44:11:3A:B8",
			Status:      "active",
			Uptime:      0,
			Bandwidth:   1000, // 1Gbps
			SegmentID:   "CORE_1",
		},
	}

	// åˆå§‹åŒ–æ±‡èšå±‚è®¾å¤‡
	distDevices := []NetworkDevice{
		{
			DeviceID:    "DIST_001",
			DeviceType:  "distribution_switch",
			IPAddress:   net.ParseIP("172.16.1.10"),
			MACAddress:  "00:1B:44:11:3A:B9",
			Status:      "active",
			Uptime:      0,
			Bandwidth:   1000, // 1Gbps
			SegmentID:   "DIST_1",
		},
	}

	// åˆå§‹åŒ–æ¥å…¥å±‚è®¾å¤‡
	accessDevices := []NetworkDevice{
		{
			DeviceID:    "ACC_001",
			DeviceType:  "access_switch",
			IPAddress:   net.ParseIP("10.1.1.1"),
			MACAddress:  "00:1B:44:11:3A:BA",
			Status:      "active",
			Uptime:      0,
			Bandwidth:   100, // 100Mbps
			SegmentID:   "ACCESS_1",
		},
		{
			DeviceID:    "ACC_002",
			DeviceType:  "access_switch",
			IPAddress:   net.ParseIP("10.1.2.1"),
			MACAddress:  "00:1B:44:11:3A:BB",
			Status:      "active",
			Uptime:      0,
			Bandwidth:   1000, // 1Gbps
			SegmentID:   "ACCESS_2",
		},
	}

	// æ·»åŠ æ‰€æœ‰è®¾å¤‡åˆ°ç®¡ç†å™¨
	allDevices := append(append(coreDevices, distDevices...), accessDevices...)

	for _, device := range allDevices {
		enm.devices[device.DeviceID] = device
	}
}

// è·å–ç½‘ç»œæ®µä¿¡æ¯
func (enm *EnterpriseNetworkManager) GetNetworkSegment(segmentID string) *NetworkSegment {
	// æ£€æŸ¥æ ¸å¿ƒå±‚
	for _, segment := range enm.topology.CoreLayer {
		if segment.SegmentID == segmentID {
			return &segment
		}
	}

	// æ£€æŸ¥æ±‡èšå±‚
	for _, segment := range enm.topology.DistributionLayer {
		if segment.SegmentID == segmentID {
			return &segment
		}
	}

	// æ£€æŸ¥æ¥å…¥å±‚
	for _, segment := range enm.topology.AccessLayer {
		if segment.SegmentID == segmentID {
			return &segment
		}
	}

	return nil
}

// è·å–ç½‘ç»œè®¾å¤‡çŠ¶æ€
func (enm *EnterpriseNetworkManager) GetDeviceStatus(deviceID string) (*NetworkDevice, bool) {
	device, exists := enm.devices[deviceID]
	return &device, exists
}

// æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
func (enm *EnterpriseNetworkManager) CheckNetworkConnectivity() map[string]bool {
	connectivityStatus := make(map[string]bool)
	var wg sync.WaitGroup
	var mu sync.Mutex

	for deviceID, device := range enm.devices {
		wg.Add(1)
		go func(id string, dev NetworkDevice) {
			defer wg.Done()

			// æ¨¡æ‹Ÿè¿é€šæ€§æ£€æŸ¥
			isReachable := enm.pingDevice(dev.IPAddress)

			mu.Lock()
			connectivityStatus[id] = isReachable
			mu.Unlock()
		}(deviceID, device)
	}

	wg.Wait()
	return connectivityStatus
}

// æ¨¡æ‹Ÿpingè®¾å¤‡
func (enm *EnterpriseNetworkManager) pingDevice(ip net.IP) bool {
	// å®é™…å®ç°ä¸­ä¼šä½¿ç”¨çœŸå®çš„pingæ£€æŸ¥
	// è¿™é‡Œæ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿå’ŒæˆåŠŸç‡
	latency := time.Duration(1+time.Now().Unix()%5) * time.Millisecond
	time.Sleep(latency)

	// 95%çš„è®¾å¤‡å¯è¾¾
	return time.Now().Unix()%100 < 95
}

// ç½‘ç»œæ‹“æ‰‘å¯è§†åŒ–
func (enm *EnterpriseNetworkManager) VisualizeTopology() {
	fmt.Println("=== ä¼ä¸šç½‘ç»œæ‹“æ‰‘ç»“æ„ ===")
	fmt.Printf("ç½‘ç»œID: %s\n", enm.topology.NetworkID)
	fmt.Printf("è®¾è®¡æ—¶é—´: %s\n\n", enm.topology.DesignTime.Format("2006-01-02 15:04:05"))

	fmt.Println("ğŸ”´ æ ¸å¿ƒå±‚ (Core Layer):")
	for _, segment := range enm.topology.CoreLayer {
		fmt.Printf("  æ®µID: %s, å­ç½‘: %s, æè¿°: %s\n",
			segment.SegmentID, segment.Subnet, segment.Description)
		displayDevicesInSegment(segment.SegmentID, enm.devices)
	}

	fmt.Println("\nğŸŸ¡ æ±‡èšå±‚ (Distribution Layer):")
	for _, segment := range enm.topology.DistributionLayer {
		fmt.Printf("  æ®µID: %s, å­ç½‘: %s, æè¿°: %s\n",
			segment.SegmentID, segment.Subnet, segment.Description)
		displayDevicesInSegment(segment.SegmentID, enm.devices)
	}

	fmt.Println("\nğŸŸ¢ æ¥å…¥å±‚ (Access Layer):")
	for _, segment := range enm.topology.AccessLayer {
		fmt.Printf("  æ®µID: %s, å­ç½‘: %s, æè¿°: %s\n",
			segment.SegmentID, segment.Subnet, segment.Description)
		displayDevicesInSegment(segment.SegmentID, enm.devices)
	}
}

// æ˜¾ç¤ºç½‘ç»œæ®µä¸­çš„è®¾å¤‡
func displayDevicesInSegment(segmentID string, devices map[string]NetworkDevice) {
	for deviceID, device := range devices {
		if device.SegmentID == segmentID {
			fmt.Printf("    è®¾å¤‡: %s (%s) - IP: %s, å¸¦å®½: %dMbps, çŠ¶æ€: %s\n",
				deviceID, device.DeviceType, device.IPAddress, device.Bandwidth, device.Status)
		}
	}
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºä¼ä¸šç½‘ç»œç®¡ç†å™¨
	netManager := CreateEnterpriseNetworkTopology()

	// æ˜¾ç¤ºç½‘ç»œæ‹“æ‰‘
	netManager.VisualizeTopology()

	// æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
	fmt.Println("\n=== ç½‘ç»œè¿é€šæ€§æ£€æŸ¥ ===")
	connectivity := netManager.CheckNetworkConnectivity()

	for deviceID, isReachable := range connectivity {
		status := "âœ… å¯è¾¾"
		if !isReachable {
			status = "âŒ ä¸å¯è¾¾"
		}
		fmt.Printf("è®¾å¤‡ %s: %s\n", deviceID, status)
	}

	// è·å–ç‰¹å®šè®¾å¤‡ä¿¡æ¯
	device, exists := netManager.GetDeviceStatus("CORE_001")
	if exists {
		fmt.Printf("\nè®¾å¤‡è¯¦æƒ…: %s - ç±»å‹: %s, IP: %s, å¸¦å®½: %dMbps\n",
			device.DeviceID, device.DeviceType, device.IPAddress, device.Bandwidth)
	}

	// è·å–ç½‘ç»œæ®µä¿¡æ¯
	segment := netManager.GetNetworkSegment("ACCESS_1")
	if segment != nil {
		fmt.Printf("ç½‘ç»œæ®µ: %s - å­ç½‘: %s, è®¾å¤‡æ•°é‡: %d\n",
			segment.SegmentID, segment.Subnet, segment.DeviceCount)
	}

	// ç›‘æ§ç½‘ç»œçŠ¶æ€
	fmt.Println("\n=== å¼€å§‹ç½‘ç»œç›‘æ§ ===")
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	go func() {
		for {
			select {
			case <-ticker.C:
				connectivity := netManager.CheckNetworkConnectivity()
				fmt.Printf("[%s] è¿é€šæ€§æ£€æŸ¥å®Œæˆï¼Œå‘ç° %d ä¸ªè®¾å¤‡\n",
					time.Now().Format("15:04:05"), len(connectivity))
			case <-netManager.ctx.Done():
				fmt.Println("ç½‘ç»œç›‘æ§å·²åœæ­¢")
				return
			}
		}
	}()

	// è¿è¡Œä¸€æ®µæ—¶é—´ååœæ­¢ç›‘æ§
	time.Sleep(2 * time.Minute)
	netManager.cancel()
	fmt.Println("ç¨‹åºè¿è¡Œå®Œæˆ")
}
```

#### 2. å†…å¤–ç½‘åˆ†ç¦»ç­–ç•¥

```go
package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

// NetworkZone ç½‘ç»œåŒºåŸŸå®šä¹‰
type NetworkZone struct {
	ZoneID          string
	ZoneName        string
	SecurityLevel   string // "public", "dmz", "internal", "confidential"
	IPRanges        []string
	AllowedPorts    []int
	BlockedPorts    []int
	AccessRules     []AccessRule
	Description     string
}

// AccessRule è®¿é—®æ§åˆ¶è§„åˆ™
type AccessRule struct {
	RuleID        string
	SourceZone    string
	DestZone      string
	Protocol      string // "tcp", "udp", "icmp", "any"
	Port          int
	Action        string // "allow", "deny", "log"
	Priority      int
	Enabled       bool
	Description   string
}

// ç½‘ç»œåŒºåŸŸç®¡ç†å™¨
type NetworkZoneManager struct {
	zones      map[string]*NetworkZone
	rules      map[string]*AccessRule
	ctx        context.Context
	cancel     context.CancelFunc
	firewall   *EnterpriseFirewall
}

// åˆ›å»ºç½‘ç»œåŒºåŸŸç®¡ç†å™¨
func CreateNetworkZoneManager() *NetworkZoneManager {
	ctx, cancel := context.WithCancel(context.Background())

	manager := &NetworkZoneManager{
		zones:  make(map[string]*NetworkZone),
		rules:  make(map[string]*AccessRule),
		ctx:    ctx,
		cancel: cancel,
		firewall: &EnterpriseFirewall{},
	}

	manager.initializeZones()
	manager.initializeAccessRules()
	return manager
}

// åˆå§‹åŒ–ç½‘ç»œåŒºåŸŸ
func (nzm *NetworkZoneManager) initializeZones() {
	// å…¬å…±åŒºåŸŸ (Public Zone)
	nzm.zones["PUBLIC"] = &NetworkZone{
		ZoneID:          "PUBLIC",
		ZoneName:        "Public Zone",
		SecurityLevel:   "public",
		IPRanges:        []string{"0.0.0.0/0"},
		AllowedPorts:    []int{80, 443},
		BlockedPorts:    []int{},
		AccessRules:     []AccessRule{},
		Description:     "Internet facing zone",
	}

	// DMZåŒºåŸŸ
	nzm.zones["DMZ"] = &NetworkZone{
		ZoneID:          "DMZ",
		ZoneName:        "DMZ Zone",
		SecurityLevel:   "dmz",
		IPRanges:        []string{"192.168.100.0/24"},
		AllowedPorts:    []int{80, 443, 8080, 8443},
		BlockedPorts:    []int{22, 3389, 1433},
		AccessRules:     []AccessRule{},
		Description:     "Demilitarized zone for public services",
	}

	// å†…éƒ¨ç½‘ç»œåŒºåŸŸ
	nzm.zones["INTERNAL"] = &NetworkZone{
		ZoneID:          "INTERNAL",
		ZoneName:        "Internal Network",
		SecurityLevel:   "internal",
		IPRanges:        []string{"10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"},
		AllowedPorts:    []int{80, 443, 53, 123},
		BlockedPorts:    []int{},
		AccessRules:     []AccessRule{},
		Description:     "Internal corporate network",
	}

	// æœºå¯†åŒºåŸŸ
	nzm.zones["CONFIDENTIAL"] = &NetworkZone{
		ZoneID:          "CONFIDENTIAL",
		ZoneName:        "Confidential Data Zone",
		SecurityLevel:   "confidential",
		IPRanges:        []string{"192.168.200.0/24"},
		AllowedPorts:    []int{443},
		BlockedPorts:    []int{80, 22, 3389},
		AccessRules:     []AccessRule{},
		Description:     "Highly sensitive data zone",
	}
}

// åˆå§‹åŒ–è®¿é—®æ§åˆ¶è§„åˆ™
func (nzm *NetworkZoneManager) initializeAccessRules() {
	rules := []AccessRule{
		{
			RuleID:      "RULE_001",
			SourceZone:  "PUBLIC",
			DestZone:    "DMZ",
			Protocol:    "tcp",
			Port:        80,
			Action:      "allow",
			Priority:    100,
			Enabled:     true,
			Description: "Allow HTTP traffic to DMZ",
		},
		{
			RuleID:      "RULE_002",
			SourceZone:  "PUBLIC",
			DestZone:    "DMZ",
			Protocol:    "tcp",
			Port:        443,
			Action:      "allow",
			Priority:    110,
			Enabled:     true,
			Description: "Allow HTTPS traffic to DMZ",
		},
		{
			RuleID:      "RULE_003",
			SourceZone:  "DMZ",
			DestZone:    "INTERNAL",
			Protocol:    "tcp",
			Port:        1433,
			Action:      "allow",
			Priority:    200,
			Enabled:     true,
			Description: "Allow database access from DMZ to Internal",
		},
		{
			RuleID:      "RULE_004",
			SourceZone:  "INTERNAL",
			DestZone:    "CONFIDENTIAL",
			Protocol:    "tcp",
			Port:        443,
			Action:      "allow",
			Priority:    300,
			Enabled:     true,
			Description: "Allow secure access to confidential zone",
		},
		{
			RuleID:      "RULE_005",
			SourceZone:  "PUBLIC",
			DestZone:    "CONFIDENTIAL",
			Protocol:    "any",
			Port:        0,
			Action:      "deny",
			Priority:    10,
			Enabled:     true,
			Description: "Deny all traffic from public to confidential",
		},
	}

	for _, rule := range rules {
		nzm.rules[rule.RuleID] = &rule
	}
}

// ä¼ä¸šé˜²ç«å¢™
type EnterpriseFirewall struct {
	ruleHits    map[string]int
	blockedIPs  map[string]time.Time
	ctx         context.Context
	cancel      context.CancelFunc
}

// æ£€æŸ¥ç½‘ç»œæµé‡æ˜¯å¦è¢«å…è®¸
func (nzm *NetworkZoneManager) CheckTrafficAccess(sourceIP, destIP net.IP, protocol string, port int) bool {
	sourceZone := nzm.identifyZone(sourceIP)
	destZone := nzm.identifyZone(destIP)

	// æŸ¥æ‰¾åŒ¹é…çš„è§„åˆ™
	matchingRule := nzm.findMatchingRule(sourceZone, destZone, protocol, port)

	if matchingRule == nil {
		return false // é»˜è®¤æ‹’ç»
	}

	if matchingRule.Action == "allow" {
		nzm.firewall.recordRuleHit(matchingRule.RuleID)
		return true
	} else if matchingRule.Action == "deny" {
		nzm.firewall.recordBlockedIP(sourceIP.String())
		return false
	}

	return false
}

// è¯†åˆ«IPåœ°å€æ‰€å±çš„ç½‘ç»œåŒºåŸŸ
func (nzm *NetworkZoneManager) identifyZone(ip net.IP) string {
	for zoneID, zone := range nzm.zones {
		for _, cidr := range zone.IPRanges {
			if isIPInCIDR(ip, cidr) {
				return zoneID
			}
		}
	}
	return "UNKNOWN"
}

// æ£€æŸ¥IPæ˜¯å¦åœ¨CIDRèŒƒå›´å†…
func isIPInCIDR(ip net.IP, cidr string) bool {
	_, network, err := net.ParseCIDR(cidr)
	if err != nil {
		return false
	}
	return network.Contains(ip)
}

// æŸ¥æ‰¾åŒ¹é…çš„è®¿é—®è§„åˆ™
func (nzm *NetworkZoneManager) findMatchingRule(sourceZone, destZone, protocol string, port int) *AccessRule {
	var bestRule *AccessRule
	highestPriority := -1

	for _, rule := range nzm.rules {
		if !rule.Enabled {
			continue
		}

		if rule.SourceZone == sourceZone && rule.DestZone == destZone {
			if rule.Protocol == protocol || rule.Protocol == "any" {
				if rule.Port == port || rule.Port == 0 {
					if rule.Priority > highestPriority {
						highestPriority = rule.Priority
						bestRule = rule
					}
				}
			}
		}
	}

	return bestRule
}

// è®°å½•è§„åˆ™å‘½ä¸­
func (fw *EnterpriseFirewall) recordRuleHit(ruleID string) {
	if fw.ruleHits == nil {
		fw.ruleHits = make(map[string]int)
	}
	fw.ruleHits[ruleID]++
}

// è®°å½•è¢«é˜»æ­¢çš„IP
func (fw *EnterpriseFirewall) recordBlockedIP(ip string) {
	if fw.blockedIPs == nil {
		fw.blockedIPs = make(map[string]time.Time)
	}
	fw.blockedIPs[ip] = time.Now()
}

// è·å–é˜²ç«å¢™ç»Ÿè®¡ä¿¡æ¯
func (fw *EnterpriseFirewall) GetFirewallStats() map[string]interface{} {
	stats := make(map[string]interface{})
	stats["rule_hits"] = fw.ruleHits
	stats["blocked_ips"] = fw.blockedIPs
	stats["total_blocked"] = len(fw.blockedIPs)
	return stats
}

// æµé‡ç›‘æ§å™¨
type TrafficMonitor struct {
	trafficLogs []TrafficLog
	ctx         context.Context
	cancel      context.CancelFunc
	mutex       sync.RWMutex
}

// TrafficLog æµé‡æ—¥å¿—
type TrafficLog struct {
	Timestamp   time.Time
	SourceIP    net.IP
	DestIP      net.IP
	Protocol    string
	Port        int
	Bytes       int64
	Action      string // "allowed", "denied"
	ZoneSource  string
	ZoneDest    string
}

// å¯åŠ¨æµé‡ç›‘æ§
func (nzm *NetworkZoneManager) StartTrafficMonitoring() *TrafficMonitor {
	ctx, cancel := context.WithCancel(context.Background())

	monitor := &TrafficMonitor{
		trafficLogs: make([]TrafficLog, 0),
		ctx:         ctx,
		cancel:      cancel,
	}

	go monitor.monitorLoop(nzm)
	return monitor
}

// ç›‘æ§å¾ªç¯
func (tm *TrafficMonitor) monitorLoop(nzm *NetworkZoneManager) {
	ticker := time.NewTicker(10 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			tm.generateTrafficSample(nzm)
		case <-tm.ctx.Done():
			fmt.Println("æµé‡ç›‘æ§å·²åœæ­¢")
			return
		}
	}
}

// ç”Ÿæˆç¤ºä¾‹æµé‡
func (tm *TrafficMonitor) generateTrafficSample(nzm *NetworkZoneManager) {
	tm.mutex.Lock()
	defer tm.mutex.Unlock()

	// ç”Ÿæˆä¸€äº›ç¤ºä¾‹æµé‡
	sampleTraffic := []struct {
		src, dst string
		protocol string
		port     int
		bytes    int64
	}{
		{"203.0.113.1", "192.168.100.10", "tcp", 80, 1024},
		{"203.0.113.2", "192.168.100.10", "tcp", 443, 2048},
		{"10.0.1.100", "192.168.200.10", "tcp", 443, 512},
		{"10.0.1.200", "192.168.100.10", "tcp", 1433, 4096},
		{"203.0.113.3", "192.168.200.10", "tcp", 22, 512},
	}

	for _, traffic := range sampleTraffic {
		srcIP := net.ParseIP(traffic.src)
		dstIP := net.ParseIP(traffic.dst)

		allowed := nzm.CheckTrafficAccess(srcIP, dstIP, traffic.protocol, traffic.port)

		action := "denied"
		if allowed {
			action = "allowed"
		}

		logEntry := TrafficLog{
			Timestamp:   time.Now(),
			SourceIP:    srcIP,
			DestIP:      dstIP,
			Protocol:    traffic.protocol,
			Port:        traffic.port,
			Bytes:       traffic.bytes,
			Action:      action,
			ZoneSource:  nzm.identifyZone(srcIP),
			ZoneDest:    nzm.identifyZone(dstIP),
		}

		tm.trafficLogs = append(tm.trafficLogs, logEntry)

		// ä¿æŒæ—¥å¿—æ•°é‡åœ¨åˆç†èŒƒå›´å†…
		if len(tm.trafficLogs) > 1000 {
			tm.trafficLogs = tm.trafficLogs[1:]
		}
	}
}

// è·å–æµé‡ç»Ÿè®¡
func (tm *TrafficMonitor) GetTrafficStats() map[string]interface{} {
	tm.mutex.RLock()
	defer tm.mutex.RUnlock()

	stats := make(map[string]interface{})
	allowedCount := 0
	deniedCount := 0
	totalBytes := int64(0)

	for _, log := range tm.trafficLogs {
		if log.Action == "allowed" {
			allowedCount++
		} else {
			deniedCount++
		}
		totalBytes += log.Bytes
	}

	stats["total_logs"] = len(tm.trafficLogs)
	stats["allowed"] = allowedCount
	stats["denied"] = deniedCount
	stats["total_bytes"] = totalBytes
	stats["latest_logs"] = tm.trafficLogs[len(tm.trafficLogs)-5:]

	return stats
}

// æ˜¾ç¤ºç½‘ç»œåŒºåŸŸé…ç½®
func (nzm *NetworkZoneManager) DisplayZoneConfiguration() {
	fmt.Println("=== ç½‘ç»œåŒºåŸŸé…ç½® ===")

	for zoneID, zone := range nzm.zones {
		fmt.Printf("\nğŸ›¡ï¸ åŒºåŸŸ: %s (%s)\n", zone.ZoneName, zoneID)
		fmt.Printf("   å®‰å…¨çº§åˆ«: %s\n", zone.SecurityLevel)
		fmt.Printf("   IPèŒƒå›´: %v\n", zone.IPRanges)
		fmt.Printf("   å…è®¸ç«¯å£: %v\n", zone.AllowedPorts)
		fmt.Printf("   é˜»æ­¢ç«¯å£: %v\n", zone.BlockedPorts)
		fmt.Printf("   æè¿°: %s\n", zone.Description)
	}

	fmt.Println("\n=== è®¿é—®æ§åˆ¶è§„åˆ™ ===")
	for ruleID, rule := range nzm.rules {
		status := "âœ… å¯ç”¨"
		if !rule.Enabled {
			status = "âŒ ç¦ç”¨"
		}
		fmt.Printf("è§„åˆ™ %s: %s -> %s (%s:%d) - %s (%s) %s\n",
			ruleID, rule.SourceZone, rule.DestZone,
			rule.Protocol, rule.Port, rule.Action,
			rule.Description, status)
	}
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºç½‘ç»œåŒºåŸŸç®¡ç†å™¨
	zoneManager := CreateNetworkZoneManager()

	// æ˜¾ç¤ºé…ç½®
	zoneManager.DisplayZoneConfiguration()

	// å¯åŠ¨æµé‡ç›‘æ§
	monitor := zoneManager.StartTrafficMonitoring()

	// è¿è¡Œä¸€æ®µæ—¶é—´æ”¶é›†æµé‡æ•°æ®
	time.Sleep(30 * time.Second)

	// è·å–æµé‡ç»Ÿè®¡
	stats := monitor.GetTrafficStats()
	fmt.Println("\n=== æµé‡ç»Ÿè®¡ ===")
	fmt.Printf("æ€»æ—¥å¿—æ•°: %v\n", stats["total_logs"])
	fmt.Printf("å…è®¸æµé‡: %v\n", stats["allowed"])
	fmt.Printf("æ‹’ç»æµé‡: %v\n", stats["denied"])
	fmt.Printf("æ€»å­—èŠ‚æ•°: %v\n", stats["total_bytes"])

	// æµ‹è¯•ç‰¹å®šæµé‡
	fmt.Println("\n=== æµé‡æµ‹è¯• ===")
	testCases := []struct {
		src, dst string
		protocol string
		port     int
		expected string
	}{
		{"203.0.113.10", "192.168.100.10", "tcp", 80, "allowed"},
		{"203.0.113.10", "192.168.100.10", "tcp", 22, "denied"},
		{"10.0.1.100", "192.168.200.10", "tcp", 443, "allowed"},
		{"10.0.1.100", "192.168.200.10", "tcp", 80, "denied"},
	}

	for _, tc := range testCases {
		srcIP := net.ParseIP(tc.src)
		dstIP := net.ParseIP(tc.dst)

		allowed := zoneManager.CheckTrafficAccess(srcIP, dstIP, tc.protocol, tc.port)
		result := "denied"
		if allowed {
			result = "allowed"
		}

		status := "âœ…"
		if result != tc.expected {
			status = "âŒ"
		}

		fmt.Printf("%s %s:%d -> %s:%d (%s) - %s (æœŸæœ›: %s)\n",
			status, tc.src, tc.port, tc.dst, tc.port, tc.protocol, result, tc.expected)
	}

	// è·å–é˜²ç«å¢™ç»Ÿè®¡
	firewallStats := zoneManager.firewall.GetFirewallStats()
	fmt.Println("\n=== é˜²ç«å¢™ç»Ÿè®¡ ===")
	fmt.Printf("è§„åˆ™å‘½ä¸­æ¬¡æ•°: %v\n", firewallStats["rule_hits"])
	fmt.Printf("è¢«é˜»æ­¢IPæ•°é‡: %v\n", firewallStats["total_blocked"])

	// åœæ­¢ç›‘æ§
	monitor.cancel()
	zoneManager.cancel()
	fmt.Println("ç¨‹åºè¿è¡Œå®Œæˆ")
}
```

#### 3. VPNæ¥å…¥æ–¹æ¡ˆ

```go
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"net"
	"sync"
	"time"
)

// VPNClient VPNå®¢æˆ·ç«¯
type VPNClient struct {
	ClientID       string
	Username       string
	PublicKey      *rsa.PublicKey
	PrivateKey     *rsa.PrivateKey
	Status         string // "connected", "disconnected", "connecting"
	ConnectTime    time.Time
	AssignedIP     net.IP
	Throughput     int64 // bytes per second
	Latency        time.Duration
	SessionToken   string
}

// VPNServer VPNæœåŠ¡å™¨
type VPNServer struct {
	ServerID       string
	Endpoint       net.IP
	Port           int
	Certificates   map[string]*x509.Certificate
	ActiveClients  map[string]*VPNClient
	SessionTokens  map[string]string
	NetworkConfig  *VPNNetworkConfig
	ctx            context.Context
	cancel         context.CancelFunc
}

// VPNNetworkConfig VPNç½‘ç»œé…ç½®
type VPNNetworkConfig struct {
	VPNSubnet     *net.IPNet
	GatewayIP     net.IP
	DNS1          net.IP
	DNS2          net.IP
	MTU           int
	Encryption    string
	Compression   bool
}

// VPNConnection VPNè¿æ¥
type VPNConnection struct {
	ConnectionID  string
	Client        *VPNClient
	Server        *VPNServer
	Established   time.Time
	SessionKey    []byte
	Encrypted     bool
	Compressed    bool
	TrafficStats  *VPNTrafficStats
}

// VPNTrafficStats VPNæµé‡ç»Ÿè®¡
type VPNTrafficStats struct {
	BytesSent     int64
	BytesReceived int64
	PacketsSent   int64
	PacketsReceived int64
	Uptime        time.Duration
}

// åˆ›å»ºVPNæœåŠ¡å™¨
func CreateVPNServer(serverID string, endpoint net.IP, port int) *VPNServer {
	ctx, cancel := context.WithCancel(context.Background())

	config := &VPNNetworkConfig{
		VPNSubnet:   parseCIDR("10.255.0.0/16"),
		GatewayIP:   net.ParseIP("10.255.0.1"),
		DNS1:        net.ParseIP("8.8.8.8"),
		DNS2:        net.ParseIP("8.8.4.4"),
		MTU:         1420,
		Encryption:  "AES-256-GCM",
		Compression: true,
	}

	server := &VPNServer{
		ServerID:       serverID,
		Endpoint:       endpoint,
		Port:           port,
		Certificates:   make(map[string]*x509.Certificate),
		ActiveClients:  make(map[string]*VPNClient),
		SessionTokens:  make(map[string]string),
		NetworkConfig:  config,
		ctx:            ctx,
		cancel:         cancel,
	}

	server.generateServerCertificate()
	return server
}

// ç”ŸæˆæœåŠ¡å™¨è¯ä¹¦
func (vs *VPNServer) generateServerCertificate() {
	// ç”ŸæˆRSAå¯†é’¥å¯¹
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		log.Fatalf("Failed to generate private key: %v", err)
	}

	publicKey := &privateKey.PublicKey

	// åˆ›å»ºè¯ä¹¦
	template := x509.Certificate{
		SerialNumber:          []byte("1"),
		Subject:              pkix.Name{Organization: []string{"VPN Server"}},
		NotBefore:            time.Now(),
		NotAfter:             time.Now().Add(365 * 24 * time.Hour),
		KeyUsage:             x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:          []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		IPAddresses:           []net.IP{vs.Endpoint},
	}

	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, publicKey, privateKey)
	if err != nil {
		log.Fatalf("Failed to create certificate: %v", err)
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		log.Fatalf("Failed to parse certificate: %v", err)
	}

	vs.Certificates[vs.ServerID] = cert

	fmt.Printf("VPNæœåŠ¡å™¨è¯ä¹¦ç”Ÿæˆå®Œæˆ: %s\n", vs.ServerID)
	fmt.Printf("è¯ä¹¦ä¸»é¢˜: %s\n", cert.Subject)
	fmt.Printf("æœ‰æ•ˆæœŸè‡³: %s\n", cert.NotAfter.Format("2006-01-02 15:04:05"))
}

// ç”Ÿæˆå®¢æˆ·ç«¯è¯ä¹¦
func (vs *VPNServer) generateClientCertificate(clientID string) (*x509.Certificate, *rsa.PrivateKey, error) {
	// ç”Ÿæˆå®¢æˆ·ç«¯ç§é’¥
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, nil, err
	}

	publicKey := &privateKey.PublicKey

	// åˆ›å»ºå®¢æˆ·ç«¯è¯ä¹¦
	template := x509.Certificate{
		SerialNumber:          []byte(clientID),
		Subject:              pkix.Name{Organization: []string{"VPN Client"}},
		NotBefore:            time.Now(),
		NotAfter:             time.Now().Add(30 * 24 * time.Hour), // 30å¤©æœ‰æ•ˆæœŸ
		KeyUsage:             x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:          []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
		BasicConstraintsValid: true,
	}

	certDER, err := x509.CreateCertificate(rand.Reader, &template, vs.Certificates[vs.ServerID], publicKey, &vs.ServerID)
	if err != nil {
		return nil, nil, err
	}

	cert, err := x509.ParseCertificate(certDER)
	if err != nil {
		return nil, nil, err
	}

	return cert, privateKey, nil
}

// å®¢æˆ·ç«¯æ³¨å†Œ
func (vs *VPNServer) RegisterClient(clientID, username string) (*VPNClient, error) {
	// ç”Ÿæˆå®¢æˆ·ç«¯è¯ä¹¦å’Œå¯†é’¥
	cert, privateKey, err := vs.generateClientCertificate(clientID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate client certificate: %v", err)
	}

	// åˆ†é…IPåœ°å€
	assignedIP := vs.assignIP()

	client := &VPNClient{
		ClientID:       clientID,
		Username:       username,
		PublicKey:      &privateKey.PublicKey,
		PrivateKey:     privateKey,
		Status:         "disconnected",
		AssignedIP:     assignedIP,
		Throughput:     0,
		Latency:        0,
		SessionToken:   "",
	}

	vs.ActiveClients[clientID] = client
	vs.Certificates[clientID] = cert

	return client, nil
}

// åˆ†é…IPåœ°å€
func (vs *VPNServer) assignIP() net.IP {
	// ç®€å•çš„IPåˆ†é…ç®—æ³•
	// å®é™…å®ç°ä¸­éœ€è¦è€ƒè™‘IPå†²çªæ£€æµ‹å’Œé‡Šæ”¾æœºåˆ¶
	baseIP := vs.NetworkConfig.VPNSubnet.IP
	ones, bits := vs.NetworkConfig.VPNSubnet.Mask.Size()

	// è·³è¿‡ç½‘ç»œåœ°å€å’Œç½‘å…³åœ°å€
	offset := 2

	clientIP := make(net.IP, len(baseIP))
	copy(clientIP, baseIP)

	// è®¡ç®—å®¢æˆ·ç«¯æ•°é‡
	clientCount := len(vs.ActiveClients)
	ipNum := offset + clientCount

	// è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åº
	for i := 0; i < 4; i++ {
		clientIP[3-i] = byte(ipNum >> (i * 8))
	}

	return clientIP
}

// å»ºç«‹VPNè¿æ¥
func (vs *VPNServer) EstablishConnection(clientID string) (*VPNConnection, error) {
	client, exists := vs.ActiveClients[clientID]
	if !exists {
		return nil, fmt.Errorf("client not found: %s", clientID)
	}

	// ç”Ÿæˆä¼šè¯ä»¤ç‰Œ
	sessionToken := generateSessionToken()
	vs.SessionTokens[clientID] = sessionToken

	// ç”Ÿæˆä¼šè¯å¯†é’¥
	sessionKey, err := generateSessionKey()
	if err != nil {
		return nil, fmt.Errorf("failed to generate session key: %v", err)
	}

	connection := &VPNConnection{
		ConnectionID:  fmt.Sprintf("CONN_%s_%d", clientID, time.Now().Unix()),
		Client:       client,
		Server:       vs,
		Established:  time.Now(),
		SessionKey:   sessionKey,
		Encrypted:    true,
		Compressed:   true,
		TrafficStats: &VPNTrafficStats{
			BytesSent:     0,
			BytesReceived: 0,
			PacketsSent:   0,
			PacketsReceived: 0,
		},
	}

	// æ›´æ–°å®¢æˆ·ç«¯çŠ¶æ€
	client.Status = "connected"
	client.ConnectTime = time.Now()
	client.SessionToken = sessionToken

	return connection, nil
}

// ç”Ÿæˆä¼šè¯ä»¤ç‰Œ
func generateSessionToken() string {
	tokenBytes := make([]byte, 32)
	_, err := rand.Read(tokenBytes)
	if err != nil {
		log.Fatal(err)
	}
	return hex.EncodeToString(tokenBytes)
}

// ç”Ÿæˆä¼šè¯å¯†é’¥
func generateSessionKey() ([]byte, error) {
	key := make([]byte, 32) // 256ä½å¯†é’¥
	_, err := rand.Read(key)
	return key, err
}

// åŠ å¯†æ•°æ®åŒ…
func (vc *VPNConnection) EncryptData(data []byte) ([]byte, error) {
	if !vc.Encrypted {
		return data, nil
	}

	// ä½¿ç”¨AES-GCMåŠ å¯†
	block, err := aes.NewCipher(vc.SessionKey)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, err
	}

	ciphertext := gcm.Seal(nonce, nonce, data, nil)
	return ciphertext, nil
}

// è§£å¯†æ•°æ®åŒ…
func (vc *VPNConnection) DecryptData(encryptedData []byte) ([]byte, error) {
	if !vc.Encrypted {
		return encryptedData, nil
	}

	block, err := aes.NewCipher(vc.SessionKey)
	if err != nil {
		return nil, err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonceSize := gcm.NonceSize()
	if len(encryptedData) < nonceSize {
		return nil, fmt.Errorf("ciphertext too short")
	}

	nonce, ciphertext := encryptedData[:nonceSize], encryptedData[nonceSize:]
	return gcm.Open(nil, nonce, ciphertext, nil)
}

// VPNè¿æ¥ç®¡ç†å™¨
type VPNConnectionManager struct {
	connections map[string]*VPNConnection
	activeConnections int
	maxConnections int
	ctx           context.Context
	cancel        context.CancelFunc
	mutex         sync.RWMutex
}

// åˆ›å»ºè¿æ¥ç®¡ç†å™¨
func CreateConnectionManager(maxConnections int) *VPNConnectionManager {
	ctx, cancel := context.WithCancel(context.Background())

	return &VPNConnectionManager{
		connections:    make(map[string]*VPNConnection),
		activeConnections: 0,
		maxConnections:   maxConnections,
		ctx:              ctx,
		cancel:           cancel,
	}
}

// æ·»åŠ è¿æ¥
func (vcm *VPNConnectionManager) AddConnection(connection *VPNConnection) error {
	vcm.mutex.Lock()
	defer vcm.mutex.Unlock()

	if vcm.activeConnections >= vcm.maxConnections {
		return fmt.Errorf("maximum connections reached: %d", vcm.maxConnections)
	}

	vcm.connections[connection.ConnectionID] = connection
	vcm.activeConnections++

	// å¯åŠ¨è¿æ¥ç›‘æ§
	go vcm.monitorConnection(connection)

	return nil
}

// ç§»é™¤è¿æ¥
func (vcm *VPNConnectionManager) RemoveConnection(connectionID string) {
	vcm.mutex.Lock()
	defer vcm.mutex.Unlock()

	if conn, exists := vcm.connections[connectionID]; exists {
		delete(vcm.connections, connectionID)
		vcm.activeConnections--

		// æ›´æ–°å®¢æˆ·ç«¯çŠ¶æ€
		conn.Client.Status = "disconnected"
		conn.Client.SessionToken = ""
	}
}

// ç›‘æ§è¿æ¥
func (vcm *VPNConnectionManager) monitorConnection(conn *VPNConnection) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			// æ£€æŸ¥è¿æ¥å¥åº·çŠ¶æ€
			health := vcm.checkConnectionHealth(conn)
			if !health {
				fmt.Printf("è¿æ¥ %s å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œå°†è¢«æ–­å¼€\n", conn.ConnectionID)
				vcm.RemoveConnection(conn.ConnectionID)
				return
			}

			// æ›´æ–°æµé‡ç»Ÿè®¡
			vcm.updateTrafficStats(conn)

		case <-vcm.ctx.Done():
			return
		}
	}
}

// æ£€æŸ¥è¿æ¥å¥åº·çŠ¶æ€
func (vcm *VPNConnectionManager) checkConnectionHealth(conn *VPNConnection) bool {
	// æ£€æŸ¥è¿æ¥æ˜¯å¦è¶…æ—¶
	uptime := time.Since(conn.Established)
	if uptime > 24*time.Hour {
		return false
	}

	// æ£€æŸ¥å®¢æˆ·ç«¯çŠ¶æ€
	if conn.Client.Status != "connected" {
		return false
	}

	// æ£€æŸ¥ä¼šè¯ä»¤ç‰Œæ˜¯å¦æœ‰æ•ˆ
	if conn.Client.SessionToken == "" {
		return false
	}

	return true
}

// æ›´æ–°æµé‡ç»Ÿè®¡
func (vcm *VPNConnectionManager) updateTrafficStats(conn *VPNConnection) {
	// æ¨¡æ‹Ÿæµé‡ç»Ÿè®¡æ›´æ–°
	conn.TrafficStats.BytesSent += 1024 // 1KB/s
	conn.TrafficStats.BytesReceived += 2048 // 2KB/s
	conn.TrafficStats.PacketsSent += 1
	conn.TrafficStats.PacketsReceived += 1
	conn.TrafficStats.Uptime = time.Since(conn.Established)

	// æ›´æ–°å®¢æˆ·ç«¯ååé‡å’Œå»¶è¿Ÿ
	conn.Client.Throughput = conn.TrafficStats.BytesReceived
	conn.Client.Latency = time.Duration(10+time.Now().Unix()%50) * time.Millisecond
}

// è·å–è¿æ¥ç»Ÿè®¡
func (vcm *VPNConnectionManager) GetConnectionStats() map[string]interface{} {
	vcm.mutex.RLock()
	defer vcm.mutex.RUnlock()

	stats := make(map[string]interface{})
	stats["active_connections"] = vcm.activeConnections
	stats["max_connections"] = vcm.maxConnections

	connectionDetails := make([]map[string]interface{}, 0)
	for _, conn := range vcm.connections {
		detail := map[string]interface{}{
			"connection_id": conn.ConnectionID,
			"client_id":     conn.Client.ClientID,
			"username":      conn.Client.Username,
			"assigned_ip":   conn.Client.AssignedIP.String(),
			"established":   conn.Established,
			"uptime":        time.Since(conn.Established),
			"bytes_sent":    conn.TrafficStats.BytesSent,
			"bytes_received": conn.TrafficStats.BytesReceived,
			"throughput":    conn.Client.Throughput,
			"latency":       conn.Client.Latency,
		}
		connectionDetails = append(connectionDetails, detail)
	}

	stats["connections"] = connectionDetails
	return stats
}

// æ˜¾ç¤ºVPNé…ç½®
func (vs *VPNServer) DisplayVPNConfiguration() {
	fmt.Printf("=== VPNæœåŠ¡å™¨é…ç½®: %s ===\n", vs.ServerID)
	fmt.Printf("ç›‘å¬åœ°å€: %s:%d\n", vs.Endpoint, vs.Port)
	fmt.Printf("VPNå­ç½‘: %s\n", vs.NetworkConfig.VPNSubnet)
	fmt.Printf("ç½‘å…³IP: %s\n", vs.NetworkConfig.GatewayIP)
	fmt.Printf("DNS1: %s, DNS2: %s\n", vs.NetworkConfig.DNS1, vs.NetworkConfig.DNS2)
	fmt.Printf("MTU: %d\n", vs.NetworkConfig.MTU)
	fmt.Printf("åŠ å¯†ç®—æ³•: %s\n", vs.NetworkConfig.Encryption)
	fmt.Printf("å‹ç¼©: %t\n", vs.NetworkConfig.Compression)
	fmt.Printf("æ´»åŠ¨å®¢æˆ·ç«¯æ•°: %d\n", len(vs.ActiveClients))
}

// æ˜¾ç¤ºå®¢æˆ·ç«¯çŠ¶æ€
func (vs *VPNServer) DisplayClientStatus() {
	fmt.Println("\n=== VPNå®¢æˆ·ç«¯çŠ¶æ€ ===")
	for clientID, client := range vs.ActiveClients {
		fmt.Printf("å®¢æˆ·ç«¯ %s (%s):\n", clientID, client.Username)
		fmt.Printf("  çŠ¶æ€: %s\n", client.Status)
		if client.Status == "connected" {
			fmt.Printf("  åˆ†é…IP: %s\n", client.AssignedIP)
			fmt.Printf("  è¿æ¥æ—¶é—´: %s\n", client.ConnectTime.Format("2006-01-02 15:04:05"))
			fmt.Printf("  ååé‡: %d bytes/s\n", client.Throughput)
			fmt.Printf("  å»¶è¿Ÿ: %v\n", client.Latency)
		}
		fmt.Println()
	}
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºVPNæœåŠ¡å™¨
	server := CreateVPNServer("VPN_SRV_001", net.ParseIP("203.0.113.100"), 1194)

	// æ˜¾ç¤ºæœåŠ¡å™¨é…ç½®
	server.DisplayVPNConfiguration()

	// æ³¨å†Œå®¢æˆ·ç«¯
	clients := []struct {
		clientID, username string
	}{
		{"CLI_001", "alice"},
		{"CLI_002", "bob"},
		{"CLI_003", "charlie"},
	}

	for _, c := range clients {
		client, err := server.RegisterClient(c.clientID, c.username)
		if err != nil {
			log.Printf("æ³¨å†Œå®¢æˆ·ç«¯å¤±è´¥: %v", err)
			continue
		}
		fmt.Printf("å®¢æˆ·ç«¯ %s æ³¨å†ŒæˆåŠŸï¼Œåˆ†é…IP: %s\n", c.username, client.AssignedIP)
	}

	// åˆ›å»ºè¿æ¥ç®¡ç†å™¨
	connManager := CreateConnectionManager(10)

	// å»ºç«‹è¿æ¥
	for clientID := range server.ActiveClients {
		conn, err := server.EstablishConnection(clientID)
		if err != nil {
			log.Printf("å»ºç«‹è¿æ¥å¤±è´¥: %v", err)
			continue
		}

		err = connManager.AddConnection(conn)
		if err != nil {
			log.Printf("æ·»åŠ è¿æ¥å¤±è´¥: %v", err)
			continue
		}

		fmt.Printf("è¿æ¥ %s å»ºç«‹æˆåŠŸ\n", conn.ConnectionID)

		// æµ‹è¯•æ•°æ®åŠ å¯†
		testData := []byte("Hello, VPN World!")
		encrypted, err := conn.EncryptData(testData)
		if err != nil {
			log.Printf("åŠ å¯†å¤±è´¥: %v", err)
			continue
		}

		decrypted, err := conn.DecryptData(encrypted)
		if err != nil {
			log.Printf("è§£å¯†å¤±è´¥: %v", err)
			continue
		}

		fmt.Printf("åŠ å¯†æµ‹è¯•: åŸå§‹=%s, è§£å¯†=%s\n", string(testData), string(decrypted))
	}

	// æ˜¾ç¤ºå®¢æˆ·ç«¯çŠ¶æ€
	server.DisplayClientStatus()

	// æ˜¾ç¤ºè¿æ¥ç»Ÿè®¡
	fmt.Println("\n=== VPNè¿æ¥ç»Ÿè®¡ ===")
	stats := connManager.GetConnectionStats()
	fmt.Printf("æ´»åŠ¨è¿æ¥æ•°: %d/%d\n", stats["active_connections"], stats["max_connections"])

	if connections, ok := stats["connections"].([]map[string]interface{}); ok {
		for _, conn := range connections {
			fmt.Printf("è¿æ¥ %s: %s@%s\n",
				conn["connection_id"],
				conn["username"],
				conn["assigned_ip"])
			fmt.Printf("  æµé‡: å‘é€=%d, æ¥æ”¶=%d bytes\n",
				conn["bytes_sent"],
				conn["bytes_received"])
			fmt.Printf("  è¿è¡Œæ—¶é—´: %v\n", conn["uptime"])
		}
	}

	// è¿è¡Œä¸€æ®µæ—¶é—´æ”¶é›†æ•°æ®
	time.Sleep(60 * time.Second)

	// å†æ¬¡æ˜¾ç¤ºç»Ÿè®¡
	fmt.Println("\n=== 60ç§’åè¿æ¥ç»Ÿè®¡ ===")
	stats = connManager.GetConnectionStats()
	fmt.Printf("æ´»åŠ¨è¿æ¥æ•°: %d/%d\n", stats["active_connections"], stats["max_connections"])

	// å…³é—­æœåŠ¡å™¨
	server.cancel()
	connManager.cancel()
	fmt.Println("VPNæœåŠ¡å™¨å·²å…³é—­")
}
```

### ä¼ä¸šç½‘ç»œå®‰å…¨é˜²æŠ¤

#### 1. ç½‘ç»œå®‰å…¨ç­–ç•¥

```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"net"
	"sync"
	"time"
)

// SecurityPolicy å®‰å…¨ç­–ç•¥
type SecurityPolicy struct {
	PolicyID       string
	Name           string
	PolicyType     string // "firewall", "ids", "ips", "antivirus", "ddos"
	Action         string // "allow", "deny", "monitor", "alert"
	Rules          []SecurityRule
	Priority       int
	Enabled        bool
	Version        string
	CreatedTime    time.Time
}

// SecurityRule å®‰å…¨è§„åˆ™
type SecurityRule struct {
	RuleID         string
	Condition      string // "src_ip", "dst_ip", "protocol", "port", "content", "frequency"
	Operator       string // "equals", "contains", "matches", "greater_than", "less_than"
	Value          string
	Action         string // "allow", "deny", "log", "alert", "block"
	Weight         int    // è§„åˆ™æƒé‡
	ExpiresAt      *time.Time
	Enabled        bool
}

// ThreatIntelligence å¨èƒæƒ…æŠ¥
type ThreatIntelligence struct {
	IPReputation   map[string]IPReputationScore
	URLBlacklist   map[string]bool
	FileHashBlacklist map[string]bool
	AttackSignatures map[string]AttackSignature
}

// IPReputationScore IPä¿¡èª‰è¯„åˆ†
type IPReputationScore struct {
	IPAddress      net.IP
	ReputationScore float64 // 0.0 - 1.0
	ThreatLevel    string // "low", "medium", "high", "critical"
	Reasons        []string
	LastUpdated    time.Time
}

// AttackSignature æ”»å‡»ç­¾å
type AttackSignature struct {
	SignatureID    string
	Name           string
	Pattern        string
	Severity       string // "low", "medium", "high", "critical"
	CVE            string
	Description    string
}

// NetworkSecurityManager ç½‘ç»œå®‰å…¨ç®¡ç†å™¨
type NetworkSecurityManager struct {
	policies       map[string]*SecurityPolicy
	threatIntel    *ThreatIntelligence
	securityEvents []SecurityEvent
	ctx            context.Context
	cancel         context.CancelFunc
	mutex          sync.RWMutex
}

// SecurityEvent å®‰å…¨äº‹ä»¶
type SecurityEvent struct {
	EventID        string
	Timestamp      time.Time
	EventType      string // "firewall_block", "ids_alert", "ddos_detected", "malware_detected"
	Severity       string // "low", "medium", "high", "critical"
	SourceIP       net.IP
	DestIP         net.IP
	Protocol       string
	Port           int
	Description    string
	PolicyID       string
	RuleID         string
	ActionTaken    string
}

// åˆ›å»ºç½‘ç»œå®‰å…¨ç®¡ç†å™¨
func CreateNetworkSecurityManager() *NetworkSecurityManager {
	ctx, cancel := context.WithCancel(context.Background())

	manager := &NetworkSecurityManager{
		policies:      make(map[string]*SecurityPolicy),
		threatIntel:   &ThreatIntellegence{
			IPReputation:    make(map[string]IPReputationScore),
			URLBlacklist:    make(map[string]bool),
			FileHashBlacklist: make(map[string]bool),
			AttackSignatures: make(map[string]AttackSignature),
		},
		securityEvents: make([]SecurityEvent, 0),
		ctx:           ctx,
		cancel:        cancel,
	}

	manager.initializeThreatIntelligence()
	manager.initializeSecurityPolicies()

	return manager
}

// åˆå§‹åŒ–å¨èƒæƒ…æŠ¥
func (nsm *NetworkSecurityManager) initializeThreatIntelligence() {
	// æ¶æ„IPåˆ—è¡¨
	maliciousIPs := []string{
		"203.0.113.10",
		"198.51.100.20",
		"192.0.2.30",
	}

	for _, ipStr := range maliciousIPs {
		ip := net.ParseIP(ipStr)
		nsm.threatIntel.IPReputation[ipStr] = IPReputationScore{
			IPAddress:      ip,
			ReputationScore: 0.1, // ä½ä¿¡èª‰
			ThreatLevel:    "high",
			Reasons:        []string{"known_malicious", "botnet_activity"},
			LastUpdated:    time.Now(),
		}
	}

	// æ¶æ„URLé»‘åå•
	nsm.threatIntel.URLBlacklist["http://malicious.example.com"] = true
	nsm.threatIntel.URLBlacklist["https://phishing.example.net"] = true

	// æ–‡ä»¶å“ˆå¸Œé»‘åå•
	nsm.threatIntel.FileHashBlacklist["a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3"] = true

	// æ”»å‡»ç­¾å
	attackSignatures := []AttackSignature{
		{
			SignatureID: "SQL_INJ_001",
			Name:        "SQL Injection",
			Pattern:     "(?i)(union|select|insert|update|delete|drop|create|alter)",
			Severity:    "high",
			CVE:         "CWE-89",
			Description: "SQLæ³¨å…¥æ”»å‡»ç‰¹å¾",
		},
		{
			SignatureID: "XSS_001",
			Name:        "Cross-Site Scripting",
			Pattern:     "(?i)(<script|javascript:|onerror=|onload=)",
			Severity:    "medium",
			CVE:         "CWE-79",
			Description: "è·¨ç«™è„šæœ¬æ”»å‡»ç‰¹å¾",
		},
		{
			SignatureID: "RCE_001",
			Name:        "Remote Code Execution",
			Pattern:     "(?i)(system|exec|shell_exec|passthru)",
			Severity:    "critical",
			CVE:         "CWE-78",
			Description: "è¿œç¨‹ä»£ç æ‰§è¡Œæ”»å‡»ç‰¹å¾",
		},
	}

	for _, sig := range attackSignatures {
		nsm.threatIntel.AttackSignatures[sig.SignatureID] = sig
	}
}

// åˆå§‹åŒ–å®‰å…¨ç­–ç•¥
func (nsm *NetworkSecurityManager) initializeSecurityPolicies() {
	// é˜²ç«å¢™ç­–ç•¥
	firewallPolicy := &SecurityPolicy{
		PolicyID:       "FW_POL_001",
		Name:           "Basic Firewall Policy",
		PolicyType:     "firewall",
		Action:         "enforce",
		Priority:       100,
		Enabled:        true,
		Version:        "1.0",
		CreatedTime:    time.Now(),
		Rules: []SecurityRule{
			{
				RuleID:    "FW_RULE_001",
				Condition: "src_ip",
				Operator:  "matches",
				Value:     "203.0.113.10", // æ¶æ„IP
				Action:    "deny",
				Weight:    1000,
				Enabled:   true,
			},
			{
				RuleID:    "FW_RULE_002",
				Condition: "dst_port",
				Operator:  "equals",
				Value:     "22",
				Action:    "monitor",
				Weight:    500,
				Enabled:   true,
			},
			{
				RuleID:    "FW_RULE_003",
				Condition: "protocol",
				Operator:  "equals",
				Value:     "tcp",
				Action:    "allow",
				Weight:    100,
				Enabled:   true,
			},
		},
	}

	// IDSç­–ç•¥
	idsPolicy := &SecurityPolicy{
		PolicyID:       "IDS_POL_001",
		Name:           "Intrusion Detection Policy",
		PolicyType:     "ids",
		Action:         "detect",
		Priority:       200,
		Enabled:        true,
		Version:        "1.0",
		CreatedTime:    time.Now(),
		Rules: []SecurityRule{
			{
				RuleID:    "IDS_RULE_001",
				Condition: "content",
				Operator:  "matches",
				Value:     "(?i)(union|select|insert|update|delete)",
				Action:    "alert",
				Weight:    800,
				Enabled:   true,
			},
			{
				RuleID:    "IDS_RULE_002",
				Condition: "frequency",
				Operator:  "greater_than",
				Value:     "100", // æ¯åˆ†é’Ÿ100æ¬¡è¯·æ±‚
				Action:    "alert",
				Weight:    700,
				Enabled:   true,
			},
		},
	}

	// DDoSé˜²æŠ¤ç­–ç•¥
	ddosPolicy := &SecurityPolicy{
		PolicyID:       "DDOS_POL_001",
		Name:           "DDoS Protection Policy",
		PolicyType:     "ddos",
		Action:         "protect",
		Priority:       300,
		Enabled:        true,
		Version:        "1.0",
		CreatedTime:    time.Now(),
		Rules: []SecurityRule{
			{
				RuleID:    "DDOS_RULE_001",
				Condition: "frequency",
				Operator:  "greater_than",
				Value:     "1000", // æ¯ç§’1000æ¬¡è¯·æ±‚
				Action:    "block",
				Weight:    900,
				Enabled:   true,
			},
		},
	}

	nsm.policies[firewallPolicy.PolicyID] = firewallPolicy
	nsm.policies[idsPolicy.PolicyID] = idsPolicy
	nsm.policies[ddosPolicy.PolicyID] = ddosPolicy
}

// ç½‘ç»œæµé‡å®‰å…¨æ£€æŸ¥
func (nsm *NetworkSecurityManager) CheckNetworkTraffic(traffic *NetworkTraffic) SecurityDecision {
	nsm.mutex.RLock()
	defer nsm.mutex.RUnlock()

	decisions := make([]SecurityDecision, 0)

	// åº”ç”¨æ‰€æœ‰å¯ç”¨çš„ç­–ç•¥
	for _, policy := range nsm.policies {
		if !policy.Enabled {
			continue
		}

		decision := nsm.applySecurityPolicy(policy, traffic)
		decisions = append(decisions, decision)

		// å¦‚æœç­–ç•¥å†³å®šæ‹’ç»ï¼Œç›´æ¥è¿”å›
		if decision.Action == "deny" || decision.Action == "block" {
			return decision
		}
	}

	// ç»¼åˆå†³ç­–
	return nsm.makeFinalDecision(decisions)
}

// NetworkTraffic ç½‘ç»œæµé‡
type NetworkTraffic struct {
	SourceIP      net.IP
	DestIP        net.IP
	Protocol      string
	Port          int
	Payload       []byte
	Timestamp     time.Time
	PacketSize    int
	Frequency     int // æ¯åˆ†é’Ÿè¯·æ±‚æ•°
}

// SecurityDecision å®‰å…¨å†³ç­–
type SecurityDecision struct {
	Action         string // "allow", "deny", "monitor", "alert", "block"
	PolicyID       string
	RuleID         string
	Reason         string
	Confidence     float64 // 0.0 - 1.0
	ThreatScore    float64 // 0.0 - 1.0
}

// åº”ç”¨å®‰å…¨ç­–ç•¥
func (nsm *NetworkSecurityManager) applySecurityPolicy(policy *SecurityPolicy, traffic *NetworkTraffic) SecurityDecision {
	var bestDecision SecurityDecision
	highestWeight := 0

	for _, rule := range policy.Rules {
		if !rule.Enabled {
			continue
		}

		if nsm.evaluateRule(&rule, traffic) {
			decision := SecurityDecision{
				Action:      rule.Action,
				PolicyID:    policy.PolicyID,
				RuleID:      rule.RuleID,
				Reason:      fmt.Sprintf("Matched rule: %s", rule.RuleID),
				Confidence:  1.0,
				ThreatScore: float64(rule.Weight) / 1000.0,
			}

			if rule.Weight > highestWeight {
				highestWeight = rule.Weight
				bestDecision = decision
			}
		}
	}

	// å¦‚æœæ²¡æœ‰åŒ¹é…è§„åˆ™ï¼Œè¿”å›é»˜è®¤å…è®¸
	if highestWeight == 0 {
		return SecurityDecision{
			Action:      "allow",
			PolicyID:    policy.PolicyID,
			Reason:      "No matching rules found",
			Confidence:  0.1,
			ThreatScore: 0.0,
		}
	}

	return bestDecision
}

// è¯„ä¼°å®‰å…¨è§„åˆ™
func (nsm *NetworkSecurityManager) evaluateRule(rule *SecurityRule, traffic *NetworkTraffic) bool {
	switch rule.Condition {
	case "src_ip":
		return nsm.checkSourceIP(rule, traffic)
	case "dst_ip":
		return nsm.checkDestIP(rule, traffic)
	case "protocol":
		return nsm.checkProtocol(rule, traffic)
	case "port":
		return nsm.checkPort(rule, traffic)
	case "content":
		return nsm.checkContent(rule, traffic)
	case "frequency":
		return nsm.checkFrequency(rule, traffic)
	default:
		return false
	}
}

// æ£€æŸ¥æºIP
func (nsm *NetworkSecurityManager) checkSourceIP(rule *SecurityRule, traffic *NetworkTraffic) bool {
	// æ£€æŸ¥IPä¿¡èª‰
	if reputation, exists := nsm.threatIntel.IPReputation[traffic.SourceIP.String()]; exists {
		return reputation.ReputationScore < 0.5 // ä¿¡èª‰ä½
	}

	// ç²¾ç¡®åŒ¹é…
	if rule.Operator == "equals" {
		return traffic.SourceIP.String() == rule.Value
	}

	return false
}

// æ£€æŸ¥ç›®æ ‡IP
func (nsm *NetworkSecurityManager) checkDestIP(rule *SecurityRule, traffic *NetworkTraffic) bool {
	if rule.Operator == "equals" {
		return traffic.DestIP.String() == rule.Value
	}
	return false
}

// æ£€æŸ¥åè®®
func (nsm *NetworkSecurityManager) checkProtocol(rule *SecurityRule, traffic *NetworkTraffic) bool {
	if rule.Operator == "equals" {
		return traffic.Protocol == rule.Value
	}
	return false
}

// æ£€æŸ¥ç«¯å£
func (nsm *NetworkSecurityManager) checkPort(rule *SecurityRule, traffic *NetworkTraffic) bool {
	if rule.Operator == "equals" {
		return fmt.Sprintf("%d", traffic.Port) == rule.Value
	}
	return false
}

// æ£€æŸ¥å†…å®¹
func (nsm *NetworkSecurityManager) checkContent(rule *SecurityRule, traffic *NetworkTraffic) bool {
	if len(traffic.Payload) == 0 {
		return false
	}

	payload := string(traffic.Payload)

	// æ£€æŸ¥æ”»å‡»ç­¾å
	for _, signature := range nsm.threatIntel.AttackSignatures {
		// è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
		if len(signature.Pattern) > 0 && len(payload) > len(signature.Pattern) {
			// ç®€å•çš„å­—ç¬¦ä¸²åŒ¹é…æ£€æŸ¥
			if containsPattern(payload, signature.Pattern) {
				return true
			}
		}
	}

	return false
}

// æ£€æŸ¥é¢‘ç‡
func (nsm *NetworkSecurityManager) checkFrequency(rule *SecurityRule, traffic *NetworkTraffic) bool {
	frequency, err := parseInt(rule.Value)
	if err != nil {
		return false
	}

	if rule.Operator == "greater_than" {
		return traffic.Frequency > frequency
	} else if rule.Operator == "less_than" {
		return traffic.Frequency < frequency
	}

	return false
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«æ¨¡å¼
func containsPattern(text, pattern string) bool {
	// ç®€åŒ–çš„æ¨¡å¼åŒ¹é…ï¼Œå®é™…åº”è¯¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼
	// è¿™é‡ŒåªåšåŸºæœ¬çš„åŒ…å«æ£€æŸ¥
	patterns := []string{"union", "select", "insert", "update", "delete", "drop", "create"}

	for _, p := range patterns {
		if len(p) > 0 && contains(text, p) {
			return true
		}
	}
	return false
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«å­å­—ç¬¦ä¸²
func contains(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// è¾…åŠ©å‡½æ•°ï¼šè§£ææ•´æ•°
func parseInt(s string) (int, error) {
	var result int
	for i := 0; i < len(s); i++ {
		if s[i] >= '0' && s[i] <= '9' {
			result = result*10 + int(s[i]-'0')
		}
	}
	return result, nil
}

// ç»¼åˆå†³ç­–
func (nsm *NetworkSecurityManager) makeFinalDecision(decisions []SecurityDecision) SecurityDecision {
	if len(decisions) == 0 {
		return SecurityDecision{
			Action:      "allow",
			Reason:      "No security policies applied",
			Confidence:  0.1,
			ThreatScore: 0.0,
		}
	}

	// æ‰¾åˆ°æœ€é«˜å¨èƒåˆ†æ•°çš„å†³ç­–
	bestDecision := decisions[0]
	maxThreatScore := bestDecision.ThreatScore

	for _, decision := range decisions[1:] {
		if decision.ThreatScore > maxThreatScore {
			maxThreatScore = decision.ThreatScore
			bestDecision = decision
		}
	}

	return bestDecision
}

// è®°å½•å®‰å…¨äº‹ä»¶
func (nsm *NetworkSecurityManager) LogSecurityEvent(event *SecurityEvent) {
	nsm.mutex.Lock()
	defer nsm.mutex.Unlock()

	nsm.securityEvents = append(nsm.securityEvents, *event)

	// ä¿æŒäº‹ä»¶æ•°é‡åœ¨åˆç†èŒƒå›´å†…
	if len(nsm.securityEvents) > 10000 {
		nsm.securityEvents = nsm.securityEvents[1:]
	}

	fmt.Printf("å®‰å…¨äº‹ä»¶ [%s]: %s (ä¸¥é‡çº§åˆ«: %s)\n",
		event.Timestamp.Format("15:04:05"),
		event.EventType,
		event.Severity)
}

// ç”Ÿæˆå®‰å…¨æŠ¥å‘Š
func (nsm *NetworkSecurityManager) GenerateSecurityReport() map[string]interface{} {
	nsm.mutex.RLock()
	defer nsm.mutex.RUnlock()

	report := make(map[string]interface{})

	// ç»Ÿè®¡å„ç±»äº‹ä»¶
	eventCounts := make(map[string]int)
	severityCounts := make(map[string]int)

	for _, event := range nsm.securityEvents {
		eventCounts[event.EventType]++
		severityCounts[event.Severity]++
	}

	report["total_events"] = len(nsm.securityEvents)
	report["event_type_counts"] = eventCounts
	report["severity_counts"] = severityCounts

	// æœ€è¿‘24å°æ—¶çš„äº‹ä»¶
	last24h := time.Now().Add(-24 * time.Hour)
	recentEvents := make([]SecurityEvent, 0)
	for _, event := range nsm.securityEvents {
		if event.Timestamp.After(last24h) {
			recentEvents = append(recentEvents, event)
		}
	}

	report["recent_events_24h"] = len(recentEvents)
	report["active_policies"] = len(nsm.policies)

	return report
}

// æ˜¾ç¤ºå®‰å…¨é…ç½®
func (nsm *NetworkSecurityManager) DisplaySecurityConfiguration() {
	fmt.Println("=== ç½‘ç»œå®‰å…¨é…ç½® ===")

	fmt.Printf("æ´»åŠ¨ç­–ç•¥æ•°é‡: %d\n", len(nsm.policies))
	for policyID, policy := range nsm.policies {
		fmt.Printf("\nğŸ›¡ï¸ ç­–ç•¥: %s (%s)\n", policy.Name, policyID)
		fmt.Printf("   ç±»å‹: %s, ä¼˜å…ˆçº§: %d\n", policy.PolicyType, policy.Priority)
		fmt.Printf("   çŠ¶æ€: %t, ç‰ˆæœ¬: %s\n", policy.Enabled, policy.Version)
		fmt.Printf("   è§„åˆ™æ•°é‡: %d\n", len(policy.Rules))

		for _, rule := range policy.Rules {
			status := "âœ…"
			if !rule.Enabled {
				status = "âŒ"
			}
			fmt.Printf("   %s è§„åˆ™: %s %s %s -> %s\n",
				status, rule.Condition, rule.Operator, rule.Value, rule.Action)
		}
	}

	fmt.Printf("\nå¨èƒæƒ…æŠ¥:\n")
	fmt.Printf("   IPä¿¡èª‰è®°å½•: %d\n", len(nsm.threatIntel.IPReputation))
	fmt.Printf("   URLé»‘åå•: %d\n", len(nsm.threatIntel.URLBlacklist))
	fmt.Printf("   æ–‡ä»¶å“ˆå¸Œé»‘åå•: %d\n", len(nsm.threatIntel.FileHashBlacklist))
	fmt.Printf("   æ”»å‡»ç­¾å: %d\n", len(nsm.threatIntel.AttackSignatures))
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºç½‘ç»œå®‰å…¨ç®¡ç†å™¨
	securityManager := CreateNetworkSecurityManager()

	// æ˜¾ç¤ºå®‰å…¨é…ç½®
	securityManager.DisplaySecurityConfiguration()

	// æ¨¡æ‹Ÿç½‘ç»œæµé‡æ£€æŸ¥
	fmt.Println("\n=== ç½‘ç»œæµé‡å®‰å…¨æ£€æŸ¥ ===")

	testTraffic := []*NetworkTraffic{
		{
			SourceIP:    net.ParseIP("203.0.113.10"), // æ¶æ„IP
			DestIP:      net.ParseIP("192.168.1.100"),
			Protocol:    "tcp",
			Port:        80,
			Payload:     []byte("GET /index.html HTTP/1.1"),
			Timestamp:   time.Now(),
			PacketSize:  1024,
			Frequency:   50,
		},
		{
			SourceIP:    net.ParseIP("192.168.1.50"), // æ­£å¸¸IP
			DestIP:      net.ParseIP("192.168.1.100"),
			Protocol:    "tcp",
			Port:        443,
			Payload:     []byte("GET /api/data HTTP/1.1"),
			Timestamp:   time.Now(),
			PacketSize:  2048,
			Frequency:   10,
		},
		{
			SourceIP:    net.ParseIP("198.51.100.20"), // æ¶æ„IP
			DestIP:      net.ParseIP("192.168.1.100"),
			Protocol:    "tcp",
			Port:        22,
			Payload:     []byte("union select * from users"),
			Timestamp:   time.Now(),
			PacketSize:  512,
			Frequency:   150, // é«˜é¢‘ç‡
		},
	}

	for i, traffic := range testTraffic {
		fmt.Printf("\næµ‹è¯•æµé‡ %d:\n", i+1)
		fmt.Printf("  æºIP: %s, ç›®æ ‡IP: %s, ç«¯å£: %d\n",
			traffic.SourceIP, traffic.DestIP, traffic.Port)
		fmt.Printf("  é¢‘ç‡: %d requests/min\n", traffic.Frequency)

		decision := securityManager.CheckNetworkTraffic(traffic)

		fmt.Printf("  å®‰å…¨å†³ç­–: %s\n", decision.Action)
		fmt.Printf("  ç­–ç•¥: %s, è§„åˆ™: %s\n", decision.PolicyID, decision.RuleID)
		fmt.Printf("  åŸå› : %s\n", decision.Reason)
		fmt.Printf("  å¨èƒåˆ†æ•°: %.2f\n", decision.ThreatScore)

		// è®°å½•å®‰å…¨äº‹ä»¶
		event := &SecurityEvent{
			EventID:     fmt.Sprintf("EVT_%d_%d", i+1, time.Now().Unix()),
			Timestamp:   time.Now(),
			EventType:   fmt.Sprintf("traffic_%s", decision.Action),
			Severity:    getSeverityFromDecision(decision),
			SourceIP:    traffic.SourceIP,
			DestIP:      traffic.DestIP,
			Protocol:    traffic.Protocol,
			Port:        traffic.Port,
			Description: fmt.Sprintf("Traffic from %s to %s:%d",
				traffic.SourceIP, traffic.DestIP, traffic.Port),
			PolicyID:    decision.PolicyID,
			RuleID:      decision.RuleID,
			ActionTaken: decision.Action,
		}

		securityManager.LogSecurityEvent(event)
	}

	// ç”Ÿæˆå®‰å…¨æŠ¥å‘Š
	fmt.Println("\n=== å®‰å…¨æŠ¥å‘Š ===")
	report := securityManager.GenerateSecurityReport()

	for key, value := range report {
		fmt.Printf("%s: %v\n", key, value)
	}

	// åœæ­¢å®‰å…¨ç®¡ç†å™¨
	securityManager.cancel()
	fmt.Println("\nç½‘ç»œå®‰å…¨ç®¡ç†å™¨å·²åœæ­¢")
}

// æ ¹æ®å†³ç­–è·å–ä¸¥é‡çº§åˆ«
func getSeverityFromDecision(decision SecurityDecision) string {
	if decision.ThreatScore > 0.8 {
		return "critical"
	} else if decision.ThreatScore > 0.6 {
		return "high"
	} else if decision.ThreatScore > 0.3 {
		return "medium"
	} else {
		return "low"
	}
}
```

ä»¥ä¸Šä»£ç ç¤ºä¾‹å±•ç¤ºäº†ä¼ä¸šç½‘ç»œå®‰å…¨é˜²æŠ¤çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬å®‰å…¨ç­–ç•¥ã€å¨èƒæƒ…æŠ¥ã€ç½‘ç»œæµé‡æ£€æŸ¥ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

...---

## â˜ï¸ äº‘åŸç”Ÿåº”ç”¨ç½‘ç»œ

### å®¹å™¨ç½‘ç»œæ¶æ„

äº‘åŸç”Ÿåº”ç”¨çš„ç½‘ç»œæ¶æ„ä¸ä¼ ç»Ÿåº”ç”¨æœ‰ç€æ˜¾è‘—å·®å¼‚ã€‚å®¹å™¨åŒ–ã€ç½‘ç»œåŒ–ã€æœåŠ¡ç½‘æ ¼åŒ–æ˜¯äº‘åŸç”Ÿç½‘ç»œçš„æ ¸å¿ƒç‰¹å¾ã€‚åœ¨äº‘åŸç”Ÿç¯å¢ƒä¸­ï¼Œç½‘ç»œä¸ä»…è¦å®ç°åŸºæœ¬çš„è¿é€šæ€§ï¼Œæ›´è¦æ”¯æŒåŠ¨æ€æ‰©ç¼©å®¹ã€æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€å®‰å…¨éš”ç¦»ç­‰é«˜çº§åŠŸèƒ½ã€‚

#### 1. å®¹å™¨ç½‘ç»œæ¥å£(CNI)å®ç°

```go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

// CNIContainer ç½‘ç»œå®¹å™¨å®šä¹‰
type CNIContainer struct {
	ContainerID   string
	PodName       string
	Namespace     string
	NetworkName   string
	IPAddress     net.IP
	MACAddress    string
	NetworkInterface string
	Links         []NetworkLink
	Created       time.Time
	Status        string // "created", "running", "stopped", "deleted"
}

// NetworkLink ç½‘ç»œè¿æ¥
type NetworkLink struct {
	TargetContainerID string
	TargetPodName     string
	NetworkName       string
	LinkType          string // "veth", "bridge", "overlay"
	Bandwidth         int64 // Mbps
	Latency           time.Duration
}

// CNINetwork CNIç½‘ç»œé…ç½®
type CNINetwork struct {
	NetworkName   string
	NetworkType   string // "bridge", "overlay", "host", "null"
	Subnet        *net.IPNet
	Gateway       net.IP
	DNS           []net.IP
	MTU           int
	IPAMConfig    IPAMConfig
	ContainerIPs  map[string]net.IP
	Created       time.Time
	Modified      time.Time
}

// IPAMConfig IPåœ°å€ç®¡ç†é…ç½®
type IPAMConfig struct {
	Type          string // "host-local", "dhcp", "static"
	Routes        []Route
	DataDir       string
	IPRanges      []IPRange
	Subnet        string
}

// Route è·¯ç”±é…ç½®
type Route struct {
	Dst    string
	GW     string
	Dev    string
	Metric int
}

// IPRange IPåœ°å€èŒƒå›´
type IPRange {
	Subnet string
	Range  string
	Gateway string
}

// ContainerNetworkManager å®¹å™¨ç½‘ç»œç®¡ç†å™¨
type ContainerNetworkManager struct {
	networks    map[string]*CNINetwork
	containers  map[string]*CNIContainer
	ctx         context.Context
	cancel      context.CancelFunc
	mutex       sync.RWMutex
}

// åˆ›å»ºå®¹å™¨ç½‘ç»œç®¡ç†å™¨
func CreateContainerNetworkManager() *ContainerNetworkManager {
	ctx, cancel := context.WithCancel(context.Background())

	manager := &ContainerNetworkManager{
		networks:   make(map[string]*CNINetwork),
		containers: make(map[string]*CNIContainer),
		ctx:        ctx,
		cancel:     cancel,
	}

	manager.initializeDefaultNetworks()
	return manager
}

// åˆå§‹åŒ–é»˜è®¤ç½‘ç»œ
func (cnm *ContainerNetworkManager) initializeDefaultNetworks() {
	// åˆ›å»ºé»˜è®¤bridgeç½‘ç»œ
	bridgeNetwork := &CNINetwork{
		NetworkName: "bridge",
		NetworkType: "bridge",
		Subnet:      parseCIDR("172.17.0.0/16"),
		Gateway:     net.ParseIP("172.17.0.1"),
		DNS:         []net.IP{net.ParseIP("8.8.8.8"), net.ParseIP("8.8.4.4")},
		MTU:         1500,
		IPAMConfig: IPAMConfig{
			Type:    "host-local",
			Routes:  []Route{{Dst: "0.0.0.0/0", GW: "172.17.0.1"}},
			DataDir: "/var/lib/cni/networks/bridge",
			IPRanges: []IPRange{{Subnet: "172.17.0.0/16", Range: "172.17.1.0-172.17.254.0", Gateway: "172.17.0.1"}},
		},
		ContainerIPs: make(map[string]net.IP),
		Created:      time.Now(),
		Modified:     time.Now(),
	}

	// åˆ›å»ºoverlayç½‘ç»œ
	overlayNetwork := &CNINetwork{
		NetworkName: "overlay",
		NetworkType: "overlay",
		Subnet:      parseCIDR("10.244.0.0/16"),
		Gateway:     net.ParseIP("10.244.0.1"),
		DNS:         []net.IP{net.ParseIP("8.8.8.8")},
		MTU:         1420,
		IPAMConfig: IPAMConfig{
			Type:    "host-local",
			DataDir: "/var/lib/cni/networks/overlay",
			Routes:  []Route{{Dst: "10.244.0.0/16", GW: "10.244.0.1"}},
			IPRanges: []IPRange{{Subnet: "10.244.0.0/16", Range: "10.244.1.0-10.244.254.0", Gateway: "10.244.0.1"}},
		},
		ContainerIPs: make(map[string]net.IP),
		Created:      time.Now(),
		Modified:     time.Now(),
	}

	cnm.networks["bridge"] = bridgeNetwork
	cnm.networks["overlay"] = overlayNetwork
}

// æ·»åŠ å®¹å™¨åˆ°ç½‘ç»œ
func (cnm *ContainerNetworkManager) AddContainerToNetwork(container *CNIContainer, networkName string) error {
	cnm.mutex.Lock()
	defer cnm.mutex.Unlock()

	network, exists := cnm.networks[networkName]
	if !exists {
		return fmt.Errorf("network not found: %s", networkName)
	}

	// æ£€æŸ¥å®¹å™¨æ˜¯å¦å·²åœ¨ç½‘ç»œä¸­
	if _, exists := cnm.containers[container.ContainerID]; exists {
		if ip, allocated := network.ContainerIPs[container.ContainerID]; allocated {
			container.IPAddress = ip
			return nil
		}
	}

	// åˆ†é…IPåœ°å€
	ip, err := cnm.allocateIP(network, container.ContainerID)
	if err != nil {
		return fmt.Errorf("failed to allocate IP: %v", err)
	}

	container.IPAddress = ip
	container.NetworkName = networkName
	container.NetworkInterface = fmt.Sprintf("eth0")
	container.MACAddress = cnm.generateMACAddress()
	container.Status = "created"
	container.Created = time.Now()

	// æ›´æ–°ç½‘ç»œå’Œå®¹å™¨æ˜ å°„
	cnm.containers[container.ContainerID] = container
	network.ContainerIPs[container.ContainerID] = ip
	network.Modified = time.Now()

	return nil
}

// åˆ†é…IPåœ°å€
func (cnm *ContainerNetworkManager) allocateIP(network *CNINetwork, containerID string) (net.IP, error) {
	// ç®€å•IPåˆ†é…ç®—æ³•
	baseIP := network.Subnet.IP
	ones, _ := network.Subnet.Mask.Size()

	// è·³è¿‡ç½‘ç»œåœ°å€å’Œç½‘å…³åœ°å€
	offset := 2

	// è®¡ç®—å·²åˆ†é…çš„IPæ•°é‡
	allocatedCount := len(network.ContainerIPs)
	ipNum := offset + allocatedCount

	// æ£€æŸ¥æ˜¯å¦è¶…å‡ºå­ç½‘èŒƒå›´
	maxIPs := 1 << (32 - ones)
	if ipNum >= maxIPs-1 {
		return nil, fmt.Errorf("network %s has no available IPs", network.NetworkName)
	}

	// è®¡ç®—IPåœ°å€
	containerIP := make(net.IP, len(baseIP))
	copy(containerIP, baseIP)

	// è½¬æ¢ä¸ºç½‘ç»œå­—èŠ‚åº
	for i := 0; i < 4; i++ {
		containerIP[3-i] = byte(ipNum >> (i * 8))
	}

	return containerIP, nil
}

// ç”ŸæˆMACåœ°å€
func (cnm *ContainerNetworkManager) generateMACAddress() string {
	// ç”ŸæˆéšæœºMACåœ°å€ï¼Œç¡®ä¿æ˜¯unicastä¸”éæœ¬åœ°ç®¡ç†
	mac := make([]byte, 6)
	mac[0] = 0x02 | 0x01 // è®¾ç½®unicastå’Œæœ¬åœ°ç®¡ç†ä½
	for i := 1; i < 6; i++ {
		mac[i] = byte(time.Now().UnixNano() >> uint((i-1)*8) & 0xFF)
	}

	return fmt.Sprintf("%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5])
}

// ç§»é™¤å®¹å™¨ä»ç½‘ç»œ
func (cnm *ContainerNetworkManager) RemoveContainerFromNetwork(containerID string) error {
	cnm.mutex.Lock()
	defer cnm.mutex.Unlock()

	container, exists := cnm.containers[containerID]
	if !exists {
		return fmt.Errorf("container not found: %s", containerID)
	}

	network, exists := cnm.networks[container.NetworkName]
	if exists {
		delete(network.ContainerIPs, containerID)
		network.Modified = time.Now()
	}

	container.Status = "deleted"
	return nil
}

// åˆ›å»ºå®¹å™¨ç½‘ç»œè¿æ¥
func (cnm *ContainerNetworkManager) CreateContainerLink(sourceContainerID, targetContainerID, networkName string) (*NetworkLink, error) {
	cnm.mutex.RLock()
	defer cnm.mutex.RUnlock()

	sourceContainer, exists := cnm.containers[sourceContainerID]
	if !exists {
		return nil, fmt.Errorf("source container not found: %s", sourceContainerID)
	}

	targetContainer, exists := cnm.containers[targetContainerID]
	if !exists {
		return nil, fmt.Errorf("target container not found: %s", targetContainerID)
	}

	if sourceContainer.NetworkName != networkName || targetContainer.NetworkName != networkName {
		return nil, fmt.Errorf("containers are not in the same network: %s", networkName)
	}

	link := &NetworkLink{
		TargetContainerID: targetContainerID,
		TargetPodName:     targetContainer.PodName,
		NetworkName:       networkName,
		LinkType:          "veth",
		Bandwidth:         1000, // 1Gbps
		Latency:           time.Millisecond,
	}

	sourceContainer.Links = append(sourceContainer.Links, *link)
	return link, nil
}

// è·å–ç½‘ç»œä¿¡æ¯
func (cnm *ContainerNetworkManager) GetNetworkInfo(networkName string) (*CNINetwork, error) {
	cnm.mutex.RLock()
	defer cnm.mutex.RUnlock()

	network, exists := cnm.networks[networkName]
	if !exists {
		return nil, fmt.Errorf("network not found: %s", networkName)
	}

	return network, nil
}

// è·å–å®¹å™¨ä¿¡æ¯
func (cnm *ContainerNetworkManager) GetContainerInfo(containerID string) (*CNIContainer, error) {
	cnm.mutex.RLock()
	defer cnm.mutex.RUnlock()

	container, exists := cnm.containers[containerID]
	if !exists {
		return nil, fmt.Errorf("container not found: %s", containerID)
	}

	return container, nil
}

// æ˜¾ç¤ºç½‘ç»œé…ç½®
func (cnm *ContainerNetworkManager) DisplayNetworkConfiguration() {
	cnm.mutex.RLock()
	defer cnm.mutex.RUnlock()

	fmt.Println("=== å®¹å™¨ç½‘ç»œé…ç½® ===")

	for networkName, network := range cnm.networks {
		fmt.Printf("\nğŸŒ ç½‘ç»œ: %s (ç±»å‹: %s)\n", networkName, network.NetworkType)
		fmt.Printf("   å­ç½‘: %s\n", network.Subnet)
		fmt.Printf("   ç½‘å…³: %s\n", network.Gateway)
		fmt.Printf("   MTU: %d\n", network.MTU)
		fmt.Printf("   DNS: %v\n", network.DNS)
		fmt.Printf("   åˆ›å»ºæ—¶é—´: %s\n", network.Created.Format("2006-01-02 15:04:05"))
		fmt.Printf("   å®¹å™¨æ•°é‡: %d\n", len(network.ContainerIPs))

		for containerID, ip := range network.ContainerIPs {
			fmt.Printf("     å®¹å™¨: %s -> %s\n", containerID, ip)
		}
	}
}

// å®¹å™¨ç½‘ç»œå¥åº·æ£€æŸ¥
func (cnm *ContainerNetworkManager) PerformNetworkHealthCheck() map[string]interface{} {
	cnm.mutex.RLock()
	defer cnm.mutex.RUnlock()

	healthStatus := make(map[string]interface{})
	networkHealth := make(map[string]interface{})

	for networkName, network := range cnm.networks {
		containerCount := len(network.ContainerIPs)
		subnetSize := 1 << (32 - network.Subnet.Mask.Size())

		utilization := float64(containerCount) / float64(subnetSize) * 100

		health := map[string]interface{}{
			"container_count":   containerCount,
			"subnet_size":       subnetSize,
			"utilization_percent": utilization,
			"status":            "healthy",
		}

		if utilization > 80 {
			health["status"] = "warning"
			health["warning"] = "High IP address utilization"
		}

		if utilization > 95 {
			health["status"] = "critical"
			health["error"] = "Network almost out of IP addresses"
		}

		networkHealth[networkName] = health
	}

	healthStatus["networks"] = networkHealth
	healthStatus["total_containers"] = len(cnm.containers)
	healthStatus["total_networks"] = len(cnm.networks)

	return healthStatus
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºå®¹å™¨ç½‘ç»œç®¡ç†å™¨
	cnm := CreateContainerNetworkManager()

	// æ˜¾ç¤ºç½‘ç»œé…ç½®
	cnm.DisplayNetworkConfiguration()

	// åˆ›å»ºæµ‹è¯•å®¹å™¨
	containers := []*CNIContainer{
		{
			ContainerID: "container-001",
			PodName:     "web-pod-1",
			Namespace:   "default",
		},
		{
			ContainerID: "container-002",
			PodName:     "db-pod-1",
			Namespace:   "default",
		},
		{
			ContainerID: "container-003",
			PodName:     "app-pod-1",
			Namespace:   "production",
		},
	}

	// å°†å®¹å™¨æ·»åŠ åˆ°ç½‘ç»œ
	for i, container := range containers {
		networkName := "bridge"
		if i == 2 { // ç¬¬ä¸‰ä¸ªå®¹å™¨ä½¿ç”¨overlayç½‘ç»œ
			networkName = "overlay"
		}

		err := cnm.AddContainerToNetwork(container, networkName)
		if err != nil {
			log.Printf("æ·»åŠ å®¹å™¨åˆ°ç½‘ç»œå¤±è´¥: %v", err)
			continue
		}

		fmt.Printf("å®¹å™¨ %s åˆ†é…åˆ°ç½‘ç»œ %sï¼ŒIP: %s\n",
			container.PodName, networkName, container.IPAddress)
	}

	// åˆ›å»ºå®¹å™¨è¿æ¥
	fmt.Println("\n=== åˆ›å»ºå®¹å™¨è¿æ¥ ===")
	link, err := cnm.CreateContainerLink("container-001", "container-002", "bridge")
	if err != nil {
		log.Printf("åˆ›å»ºå®¹å™¨è¿æ¥å¤±è´¥: %v", err)
	} else {
		fmt.Printf("å®¹å™¨è¿æ¥åˆ›å»ºæˆåŠŸ: %s -> %s (ç±»å‹: %s)\n",
			link.TargetContainerID, link.TargetPodName, link.LinkType)
	}

	// æ˜¾ç¤ºç½‘ç»œé…ç½®
	fmt.Println("\n=== æ›´æ–°åçš„ç½‘ç»œé…ç½® ===")
	cnm.DisplayNetworkConfiguration()

	// å¥åº·æ£€æŸ¥
	fmt.Println("\n=== ç½‘ç»œå¥åº·æ£€æŸ¥ ===")
	health := cnm.PerformNetworkHealthCheck()

	for networkName, healthInfo := range health {
		if networkName == "networks" {
			for netName, netHealth := range healthInfo.(map[string]interface{}) {
				fmt.Printf("ç½‘ç»œ %s:\n", netName)
				fmt.Printf("  å®¹å™¨æ•°é‡: %v\n", netHealth.(map[string]interface{})["container_count"])
				fmt.Printf("  åˆ©ç”¨ç‡: %.2f%%\n", netHealth.(map[string]interface{})["utilization_percent"])
				fmt.Printf("  çŠ¶æ€: %v\n", netHealth.(map[string]interface{})["status"])
			}
		}
	}

	// æµ‹è¯•è·å–ç‰¹å®šå®¹å™¨ä¿¡æ¯
	container, err := cnm.GetContainerInfo("container-001")
	if err != nil {
		log.Printf("è·å–å®¹å™¨ä¿¡æ¯å¤±è´¥: %v", err)
	} else {
		fmt.Printf("\nå®¹å™¨ä¿¡æ¯: %s (Pod: %s, IP: %s, MAC: %s)\n",
			container.ContainerID, container.PodName, container.IPAddress, container.MACAddress)
	}

	// æµ‹è¯•è·å–ç‰¹å®šç½‘ç»œä¿¡æ¯
	network, err := cnm.GetNetworkInfo("bridge")
	if err != nil {
		log.Printf("è·å–ç½‘ç»œä¿¡æ¯å¤±è´¥: %v", err)
	} else {
		fmt.Printf("ç½‘ç»œä¿¡æ¯: %s (ç±»å‹: %s, å­ç½‘: %s)\n",
			network.NetworkName, network.NetworkType, network.Subnet)
	}

	// æ¸…ç†å®¹å™¨
	err = cnm.RemoveContainerFromNetwork("container-001")
	if err != nil {
		log.Printf("ç§»é™¤å®¹å™¨å¤±è´¥: %v", err)
	} else {
		fmt.Printf("å®¹å™¨ %s å·²ä»ç½‘ç»œç§»é™¤\n", "container-001")
	}

	// åœæ­¢ç½‘ç»œç®¡ç†å™¨
	cnm.cancel()
	fmt.Println("\nå®¹å™¨ç½‘ç»œç®¡ç†å™¨å·²åœæ­¢")
}
```

#### 2. KubernetesæœåŠ¡å‘ç°æœºåˆ¶

```go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"strconv"
	"sync"
	"time"
)

// K8sService KubernetesæœåŠ¡
type K8sService struct {
	Name         string
	Namespace    string
	ClusterIP    net.IP
	Port         int
	TargetPort   int
	Protocol     string // "TCP", "UDP"
	Selector     map[string]string
	Endpoints    []Endpoint
	Created      time.Time
	Updated      time.Time
}

// Endpoint æœåŠ¡ç«¯ç‚¹
type Endpoint struct {
	IP       net.IP
	Port     int
	Protocol string
	Ready    bool
	PodName  string
	HostIP   net.IP
}

// K8sPod Kubernetes Pod
type K8sPod struct {
	Name         string
	Namespace    string
	IP           net.IP
	Labels       map[string]string
	Status       string // "Pending", "Running", "Succeeded", "Failed", "Unknown"
	NodeName     string
	Created      time.Time
	Ready        bool
	RestartCount int
}

// K8sServiceRegistry KubernetesæœåŠ¡æ³¨å†Œè¡¨
type K8sServiceRegistry struct {
	services    map[string]*K8sService
	pods        map[string]*K8sPod
	endpoints   map[string][]Endpoint
	ctx         context.Context
	cancel      context.CancelFunc
	mutex       sync.RWMutex
	wg          sync.WaitGroup
}

// åˆ›å»ºæœåŠ¡æ³¨å†Œè¡¨
func CreateK8sServiceRegistry() *K8sServiceRegistry {
	ctx, cancel := context.WithCancel(context.Background())

	registry := &K8sServiceRegistry{
		services:  make(map[string]*K8sService),
		pods:      make(map[string]*K8sPod),
		endpoints: make(map[string][]Endpoint),
		ctx:       ctx,
		cancel:    cancel,
	}

	registry.initializeDefaultServices()
	return registry
}

// åˆå§‹åŒ–é»˜è®¤æœåŠ¡
func (ksr *K8sServiceRegistry) initializeDefaultServices() {
	// åˆ›å»ºæ ¸å¿ƒDNSæœåŠ¡
	dnsService := &K8sService{
		Name:         "kube-dns",
		Namespace:    "kube-system",
		ClusterIP:    net.ParseIP("10.96.0.10"),
		Port:         53,
		TargetPort:   53,
		Protocol:     "TCP",
		Selector:     map[string]string{"k8s-app": "kube-dns"},
		Created:      time.Now(),
		Updated:      time.Now(),
	}

	// åˆ›å»ºç¤ºä¾‹åº”ç”¨æœåŠ¡
	appService := &K8sService{
		Name:         "my-app",
		Namespace:    "default",
		ClusterIP:    net.ParseIP("10.96.100.1"),
		Port:         80,
		TargetPort:   8080,
		Protocol:     "TCP",
		Selector:     map[string]string{"app": "my-app"},
		Created:      time.Now(),
		Updated:      time.Now(),
	}

	ksr.services[ksr.getServiceKey("kube-system", "kube-dns")] = dnsService
	ksr.services[ksr.getServiceKey("default", "my-app")] = appService
}

// è·å–æœåŠ¡é”®
func (ksr *K8sServiceRegistry) getServiceKey(namespace, name string) string {
	return fmt.Sprintf("%s/%s", namespace, name)
}

// æ³¨å†ŒæœåŠ¡
func (ksr *K8sServiceRegistry) RegisterService(service *K8sService) error {
	ksr.mutex.Lock()
	defer ksr.mutex.Unlock()

	serviceKey := ksr.getServiceKey(service.Namespace, service.Name)
	ksr.services[serviceKey] = service

	// åˆå§‹åŒ–æœåŠ¡ç«¯ç‚¹
	if _, exists := ksr.endpoints[serviceKey]; !exists {
		ksr.endpoints[serviceKey] = make([]Endpoint, 0)
	}

	// æ›´æ–°æœåŠ¡æ—¶é—´
	service.Updated = time.Now()

	return nil
}

// æ³¨é”€æœåŠ¡
func (ksr *K8sServiceRegistry) UnregisterService(namespace, name string) error {
	ksr.mutex.Lock()
	defer ksr.mutex.Unlock()

	serviceKey := ksr.getServiceKey(namespace, name)
	delete(ksr.services, serviceKey)
	delete(ksr.endpoints, serviceKey)

	return nil
}

// æ³¨å†ŒPod
func (ksr *K8sServiceRegistry) RegisterPod(pod *K8sPod) error {
	ksr.mutex.Lock()
	defer ksr.mutex.Unlock()

	podKey := ksr.getPodKey(pod.Namespace, pod.Name)
	ksr.pods[podKey] = pod

	// æ›´æ–°ç›¸å…³æœåŠ¡çš„ç«¯ç‚¹
	ksr.updateServiceEndpoints(pod)

	return nil
}

// è·å–Podé”®
func (ksr *K8sServiceRegistry) getPodKey(namespace, name string) string {
	return fmt.Sprintf("%s/%s", namespace, name)
}

// æ³¨é”€Pod
func (ksr *K8sServiceRegistry) UnregisterPod(namespace, name string) error {
	ksr.mutex.Lock()
	defer ksr.mutex.Unlock()

	podKey := ksr.getPodKey(namespace, name)
	pod, exists := ksr.pods[podKey]
	if !exists {
		return fmt.Errorf("pod not found: %s/%s", namespace, name)
	}

	// åˆ é™¤Pod
	delete(ksr.pods, podKey)

	// æ›´æ–°ç›¸å…³æœåŠ¡çš„ç«¯ç‚¹
	ksr.updateServiceEndpoints(pod)

	return nil
}

// æ›´æ–°æœåŠ¡ç«¯ç‚¹
func (ksr *K8sServiceRegistry) updateServiceEndpoints(pod *K8sPod) {
	for serviceKey, service := range ksr.services {
		if service.Namespace != pod.Namespace {
			continue
		}

		// æ£€æŸ¥Podæ˜¯å¦åŒ¹é…æœåŠ¡é€‰æ‹©å™¨
		if ksr.podMatchesService(pod, service) {
			if pod.Ready && pod.Status == "Running" {
				// æ·»åŠ æˆ–æ›´æ–°ç«¯ç‚¹
				ksr.addEndpoint(serviceKey, pod)
			} else {
				// ç§»é™¤ç«¯ç‚¹
				ksr.removeEndpoint(serviceKey, pod)
			}
		} else {
			// Podä¸åŒ¹é…æœåŠ¡ï¼Œç§»é™¤ç«¯ç‚¹
			ksr.removeEndpoint(serviceKey, pod)
		}
	}
}

// æ£€æŸ¥Podæ˜¯å¦åŒ¹é…æœåŠ¡é€‰æ‹©å™¨
func (ksr *K8sServiceRegistry) podMatchesService(pod *K8sPod, service *K8sService) bool {
	for key, value := range service.Selector {
		podValue, exists := pod.Labels[key]
		if !exists || podValue != value {
			return false
		}
	}
	return true
}

// æ·»åŠ ç«¯ç‚¹
func (ksr *K8sServiceRegistry) addEndpoint(serviceKey string, pod *K8sPod) {
	endpoints := ksr.endpoints[serviceKey]

	// æ£€æŸ¥ç«¯ç‚¹æ˜¯å¦å·²å­˜åœ¨
	for i, endpoint := range endpoints {
		if endpoint.PodName == pod.Name {
			// æ›´æ–°ç°æœ‰ç«¯ç‚¹
			endpoints[i].Ready = pod.Ready
			endpoints[i].IP = pod.IP
			return
		}
	}

	// æ·»åŠ æ–°ç«¯ç‚¹
	newEndpoint := Endpoint{
		IP:       pod.IP,
		Port:     8080, // ç›®æ ‡ç«¯å£
		Protocol: "TCP",
		Ready:    pod.Ready,
		PodName:  pod.Name,
		HostIP:   net.ParseIP("192.168.1.100"), // å‡è®¾ä¸»æœºIP
	}

	ksr.endpoints[serviceKey] = append(endpoints, newEndpoint)
}

// ç§»é™¤ç«¯ç‚¹
func (ksr *K8sServiceRegistry) removeEndpoint(serviceKey string, pod *K8sPod) {
	endpoints := ksr.endpoints[serviceKey]

	for i, endpoint := range endpoints {
		if endpoint.PodName == pod.Name {
			// ç§»é™¤ç«¯ç‚¹
			ksr.endpoints[serviceKey] = append(endpoints[:i], endpoints[i+1:]...)
			break
		}
	}
}

// æœåŠ¡å‘ç°
func (ksr *K8sServiceRegistry) DiscoverService(namespace, name string) (*K8sService, error) {
	ksr.mutex.RLock()
	defer ksr.mutex.RUnlock()

	serviceKey := ksr.getServiceKey(namespace, name)
	service, exists := ksr.services[serviceKey]
	if !exists {
		return nil, fmt.Errorf("service not found: %s/%s", namespace, name)
	}

	return service, nil
}

// è·å–æœåŠ¡ç«¯ç‚¹
func (ksr *K8sServiceRegistry) GetServiceEndpoints(namespace, name string) ([]Endpoint, error) {
	ksr.mutex.RLock()
	defer ksr.mutex.RUnlock()

	serviceKey := ksr.getServiceKey(namespace, name)
	endpoints, exists := ksr.endpoints[serviceKey]
	if !exists {
		return nil, fmt.Errorf("endpoints not found for service: %s/%s", namespace, name)
	}

	return endpoints, nil
}

// DNSè§£æ
func (ksr *K8sServiceRegistry) DNSResolve(serviceName, namespace string, domain ...string) (net.IP, error) {
	// æ„å»ºå®Œæ•´çš„DNSåç§°
	var dnsName string
	if len(domain) > 0 {
		dnsName = fmt.Sprintf("%s.%s.%s.svc.cluster.local", serviceName, namespace, domain[0])
	} else {
		dnsName = fmt.Sprintf("%s.%s.svc.cluster.local", serviceName, namespace)
	}

	service, err := ksr.DiscoverService(namespace, serviceName)
	if err != nil {
		return nil, err
	}

	// è¿”å›æœåŠ¡çš„ClusterIP
	return service.ClusterIP, nil
}

// å¥åº·æ£€æŸ¥
func (ksr *K8sServiceRegistry) PerformHealthCheck() map[string]interface{} {
	ksr.mutex.RLock()
	defer ksr.mutex.RUnlock()

	healthStatus := make(map[string]interface{})

	// æ£€æŸ¥æœåŠ¡å¥åº·çŠ¶æ€
	serviceHealth := make(map[string]interface{})
	for serviceKey, service := range ksr.services {
		endpoints := ksr.endpoints[serviceKey]
		readyEndpoints := 0

		for _, endpoint := range endpoints {
			if endpoint.Ready {
				readyEndpoints++
			}
		}

		health := map[string]interface{}{
			"service_name": service.Name,
			"namespace": service.Namespace,
			"cluster_ip": service.ClusterIP.String(),
			"port": service.Port,
			"total_endpoints": len(endpoints),
			"ready_endpoints": readyEndpoints,
			"status": "healthy",
		}

		if readyEndpoints == 0 && len(endpoints) > 0 {
			health["status"] = "unhealthy"
			health["warning"] = "No ready endpoints"
		} else if readyEndpoints < len(endpoints) {
			health["status"] = "degraded"
			health["warning"] = "Some endpoints are not ready"
		}

		serviceHealth[serviceKey] = health
	}

	healthStatus["services"] = serviceHealth
	healthStatus["total_services"] = len(ksr.services)
	healthStatus["total_pods"] = len(ksr.pods)
	healthStatus["total_endpoints"] = len(ksr.endpoints)

	return healthStatus
}

// æ˜¾ç¤ºæœåŠ¡æ³¨å†Œè¡¨
func (ksr *K8sServiceRegistry) DisplayServiceRegistry() {
	ksr.mutex.RLock()
	defer ksr.mutex.RUnlock()

	fmt.Println("=== KubernetesæœåŠ¡æ³¨å†Œè¡¨ ===")

	for serviceKey, service := range ksr.services {
		fmt.Printf("\nğŸ”§ æœåŠ¡: %s/%s\n", service.Namespace, service.Name)
		fmt.Printf("   ClusterIP: %s:%d -> %d\n", service.ClusterIP, service.Port, service.TargetPort)
		fmt.Printf("   åè®®: %s\n", service.Protocol)
		fmt.Printf("   é€‰æ‹©å™¨: %v\n", service.Selector)

		// æ˜¾ç¤ºç«¯ç‚¹
		endpoints := ksr.endpoints[serviceKey]
		fmt.Printf("   ç«¯ç‚¹æ•°é‡: %d\n", len(endpoints))

		for _, endpoint := range endpoints {
			status := "ğŸŸ¢ å°±ç»ª"
			if !endpoint.Ready {
				status = "ğŸ”´ æœªå°±ç»ª"
			}
			fmt.Printf("     %s %s:%d (Pod: %s)\n", status, endpoint.IP, endpoint.Port, endpoint.PodName)
		}
	}

	fmt.Printf("\n=== Podåˆ—è¡¨ ===")
	for podKey, pod := range ksr.pods {
		status := "ğŸŸ¢ è¿è¡Œä¸­"
		if pod.Status != "Running" {
			status = "ğŸ”´ " + pod.Status
		}

		fmt.Printf("\nğŸ“¦ Pod: %s/%s\n", pod.Namespace, pod.Name)
		fmt.Printf("   IP: %s\n", pod.IP)
		fmt.Printf("   çŠ¶æ€: %s\n", status)
		fmt.Printf("   èŠ‚ç‚¹: %s\n", pod.NodeName)
		fmt.Printf("   æ ‡ç­¾: %v\n", pod.Labels)
	}
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºæœåŠ¡æ³¨å†Œè¡¨
	registry := CreateK8sServiceRegistry()

	// æ˜¾ç¤ºæœåŠ¡æ³¨å†Œè¡¨
	registry.DisplayServiceRegistry()

	// æ³¨å†Œä¸€äº›æµ‹è¯•Pod
	pods := []*K8sPod{
		{
			Name:      "my-app-pod-1",
			Namespace: "default",
			IP:        net.ParseIP("10.244.1.10"),
			Labels:    map[string]string{"app": "my-app", "version": "v1"},
			Status:    "Running",
			NodeName:  "node-1",
			Created:   time.Now(),
			Ready:     true,
		},
		{
			Name:      "my-app-pod-2",
			Namespace: "default",
			IP:        net.ParseIP("10.244.1.11"),
			Labels:    map[string]string{"app": "my-app", "version": "v1"},
			Status:    "Running",
			NodeName:  "node-2",
			Created:   time.Now(),
			Ready:     true,
		},
		{
			Name:      "redis-pod-1",
			Namespace: "default",
			IP:        net.ParseIP("10.244.1.20"),
			Labels:    map[string]string{"app": "redis"},
			Status:    "Running",
			NodeName:  "node-1",
			Created:   time.Now(),
			Ready:     true,
		},
	}

	// æ³¨å†ŒPod
	for _, pod := range pods {
		err := registry.RegisterPod(pod)
		if err != nil {
			log.Printf("æ³¨å†ŒPodå¤±è´¥: %v", err)
			continue
		}
		fmt.Printf("Pod %s/%s æ³¨å†ŒæˆåŠŸï¼ŒIP: %s\n", pod.Namespace, pod.Name, pod.IP)
	}

	// æ›´æ–°åçš„æœåŠ¡æ³¨å†Œè¡¨
	fmt.Println("\n=== æ›´æ–°åçš„æœåŠ¡æ³¨å†Œè¡¨ ===")
	registry.DisplayServiceRegistry()

	// æœåŠ¡å‘ç°æµ‹è¯•
	fmt.Println("\n=== æœåŠ¡å‘ç°æµ‹è¯• ===")

	// æŸ¥æ‰¾my-appæœåŠ¡
	service, err := registry.DiscoverService("default", "my-app")
	if err != nil {
		log.Printf("æœåŠ¡å‘ç°å¤±è´¥: %v", err)
	} else {
		fmt.Printf("å‘ç°æœåŠ¡: %s/%s (ClusterIP: %s)\n", service.Namespace, service.Name, service.ClusterIP)

		// è·å–ç«¯ç‚¹
		endpoints, err := registry.GetServiceEndpoints("default", "my-app")
		if err != nil {
			log.Printf("è·å–ç«¯ç‚¹å¤±è´¥: %v", err)
		} else {
			fmt.Printf("ç«¯ç‚¹åˆ—è¡¨:\n")
			for _, endpoint := range endpoints {
				fmt.Printf("  - %s:%d (å°±ç»ª: %t)\n", endpoint.IP, endpoint.Port, endpoint.Ready)
			}
		}
	}

	// DNSè§£ææµ‹è¯•
	fmt.Println("\n=== DNSè§£ææµ‹è¯• ===")

	dnsTests := []struct {
		serviceName, namespace, domain string
	}{
		{"my-app", "default", ""},
		{"kube-dns", "kube-system", ""},
		{"my-app", "default", "svc"},
	}

	for _, test := range dnsTests {
		ip, err := registry.DNSResolve(test.serviceName, test.namespace, test.domain)
		if err != nil {
			fmt.Printf("DNSè§£æå¤±è´¥ %s.%s.%s: %v\n", test.serviceName, test.namespace, test.domain, err)
		} else {
			dnsName := fmt.Sprintf("%s.%s.svc.cluster.local", test.serviceName, test.namespace)
			if test.domain != "" {
				dnsName = fmt.Sprintf("%s.%s.%s.svc.cluster.local", test.serviceName, test.namespace, test.domain)
			}
			fmt.Printf("DNSè§£æ %s -> %s\n", dnsName, ip)
		}
	}

	// å¥åº·æ£€æŸ¥
	fmt.Println("\n=== æœåŠ¡å¥åº·æ£€æŸ¥ ===")
	health := registry.PerformHealthCheck()

	for key, value := range health {
		if key == "services" {
			for serviceKey, healthInfo := range value.(map[string]interface{}) {
				fmt.Printf("æœåŠ¡ %s:\n", serviceKey)
				serviceHealth := healthInfo.(map[string]interface{})
				fmt.Printf("  çŠ¶æ€: %v\n", serviceHealth["status"])
				fmt.Printf("  ç«¯ç‚¹: %v/%v å°±ç»ª\n",
					serviceHealth["ready_endpoints"], serviceHealth["total_endpoints"])
				if warning, exists := serviceHealth["warning"]; exists {
					fmt.Printf("  è­¦å‘Š: %v\n", warning)
				}
			}
		} else {
			fmt.Printf("%s: %v\n", key, value)
		}
	}

	// æ¨¡æ‹ŸPodçŠ¶æ€å˜åŒ–
	fmt.Println("\n=== æ¨¡æ‹ŸPodçŠ¶æ€å˜åŒ– ===")

	// å°†ä¸€ä¸ªPodè®¾ç½®ä¸ºä¸å°±ç»ª
	pod, err := registry.GetPod("default", "my-app-pod-1")
	if err == nil {
		pod.Ready = false
		pod.Status = "Running"
		registry.RegisterPod(pod) // æ›´æ–°Pod

		fmt.Printf("Pod %s çŠ¶æ€æ›´æ–°ä¸ºä¸å°±ç»ª\n", pod.Name)

		// å†æ¬¡æ£€æŸ¥æœåŠ¡
		endpoints, err := registry.GetServiceEndpoints("default", "my-app")
		if err == nil {
			fmt.Printf("my-appæœåŠ¡ç«¯ç‚¹æ›´æ–°:\n")
			for _, endpoint := range endpoints {
				status := "å°±ç»ª"
				if !endpoint.Ready {
					status = "æœªå°±ç»ª"
				}
				fmt.Printf("  - %s:%d (%s)\n", endpoint.IP, endpoint.Port, status)
			}
		}
	}

	// åœæ­¢æœåŠ¡æ³¨å†Œè¡¨
	registry.cancel()
	fmt.Println("\nKubernetesæœåŠ¡æ³¨å†Œè¡¨å·²åœæ­¢")
}

// è·å–Podä¿¡æ¯ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
func (ksr *K8sServiceRegistry) GetPod(namespace, name string) (*K8sPod, error) {
	ksr.mutex.RLock()
	defer ksr.mutex.RUnlock()

	podKey := ksr.getPodKey(namespace, name)
	pod, exists := ksr.pods[podKey]
	if !exists {
		return nil, fmt.Errorf("pod not found: %s/%s", namespace, name)
	}

	return pod, nil
}
```

#### 3. æœåŠ¡ç½‘æ ¼é€šä¿¡

```go
package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"sync"
	"time"
)

// ServiceMeshConfig æœåŠ¡ç½‘æ ¼é…ç½®
type ServiceMeshConfig struct {
	MeshID         string
	ControlPlane   string
	DataPlane      string
	MTLSPolicy     string // "STRICT", "PERMISSIVE"
	ProxyPort      int
	ManagementPort int
	TracingEnabled bool
	MetricsEnabled bool
	CertificateTTL time.Duration
}

// SidecarProxy è¾¹è½¦ä»£ç†
type SidecarProxy struct {
	ServiceName    string
	ServiceVersion string
	Namespace      string
	PodIP          net.IP
	ManagementIP   net.IP
	OutboundRules  []OutboundRule
InboundRules    []InboundRule
	Certificates   map[string]*x509.Certificate
	Stats          ProxyStats
	Created        time.Time
}

// OutboundRule å‡ºç«™è§„åˆ™
type OutboundRule struct {
	ServiceName    string
	ServiceVersion string
	TargetIP       net.IP
	TargetPort     int
	Protocol       string // "http", "https", "tcp"
	Weight         int    // è´Ÿè½½å‡è¡¡æƒé‡
	Timeout        time.Duration
	RetryPolicy    RetryPolicy
	RateLimit      RateLimit
}

// InboundRule å…¥ç«™è§„åˆ™
type InboundRule struct {
	SourceService    string
	SourceVersion   string
	SourceNamespace string
	Path            string
	Method          string
	Timeout         time.Duration
	AuthPolicy      string // "none", "mutual_tls", "jwt"
}

// RetryPolicy é‡è¯•ç­–ç•¥
type RetryPolicy {
	MaxRetries      int
	PerTryTimeout   time.Duration
	Backoff         string // "exponential", "fixed"
	BaseDelay       time.Duration
	MaxBackoffDelay time.Duration
}

// RateLimit é€Ÿç‡é™åˆ¶
type RateLimit {
	RequestsPerSecond int
	Burst             int
	TokenBucket       int
}

// ProxyStats ä»£ç†ç»Ÿè®¡
type ProxyStats {
	RequestsTotal        int64
	RequestsSuccess      int64
	RequestsFailure      int64
	RequestLatencyAvg    time.Duration
	OutboundConnections  int
	InboundConnections   int
	CertificateExpirations []time.Time
}

// TrafficPolicy æµé‡ç­–ç•¥
type TrafficPolicy struct {
	PolicyName      string
	ServiceName     string
	ServiceVersion  string
	LoadBalancing   string // "ROUND_ROBIN", "LEAST_CONN", "RANDOM"
	CircuitBreaker  CircuitBreaker
	Timeout         time.Duration
	Retries         RetryPolicy
}

// CircuitBreaker ç†”æ–­å™¨
type CircuitBreaker struct {
	FailureThreshold  int
	SuccessThreshold  int
	Timeout           time.Duration
	HalfOpenMaxCalls int
}

// ServiceMeshManager æœåŠ¡ç½‘æ ¼ç®¡ç†å™¨
type ServiceMeshManager struct {
	config          *ServiceMeshConfig
	proxies         map[string]*SidecarProxy
	trafficPolicies map[string]*TrafficPolicy
	ctx             context.Context
	cancel          context.CancelFunc
	mutex           sync.RWMutex
}

// åˆ›å»ºæœåŠ¡ç½‘æ ¼ç®¡ç†å™¨
func CreateServiceMeshManager(config *ServiceMeshConfig) *ServiceMeshManager {
	ctx, cancel := context.WithCancel(context.Background())

	manager := &ServiceMeshManager{
		config:          config,
		proxies:         make(map[string]*SidecarProxy),
		trafficPolicies: make(map[string]*TrafficPolicy),
		ctx:             ctx,
		cancel:          cancel,
	}

	manager.initializeDefaultPolicies()
	return manager
}

// åˆå§‹åŒ–é»˜è®¤æµé‡ç­–ç•¥
func (smm *ServiceMeshManager) initializeDefaultPolicies() {
	// ä¸ºå¸¸è§æœåŠ¡åˆ›å»ºé»˜è®¤ç­–ç•¥
	defaultPolicies := []*TrafficPolicy{
		{
			PolicyName:     "default-service-policy",
			ServiceName:    "*",
			ServiceVersion: "*",
			LoadBalancing:  "ROUND_ROBIN",
			CircuitBreaker: CircuitBreaker{
				FailureThreshold:  5,
				SuccessThreshold:  3,
				Timeout:          30 * time.Second,
				HalfOpenMaxCalls: 2,
			},
			Timeout: 10 * time.Second,
			Retries: RetryPolicy{
				MaxRetries:      3,
				PerTryTimeout:   2 * time.Second,
				Backoff:         "exponential",
				BaseDelay:       100 * time.Millisecond,
				MaxBackoffDelay: 10 * time.Second,
			},
		},
	}

	for _, policy := range defaultPolicies {
		policyKey := smm.getPolicyKey(policy.ServiceName, policy.ServiceVersion)
		smm.trafficPolicies[policyKey] = policy
	}
}

// è·å–ç­–ç•¥é”®
func (smm *ServiceMeshManager) getPolicyKey(serviceName, version string) string {
	return fmt.Sprintf("%s:%s", serviceName, version)
}

// æ³¨å†Œè¾¹è½¦ä»£ç†
func (smm *ServiceMeshManager) RegisterProxy(proxy *SidecarProxy) error {
	smm.mutex.Lock()
	defer smm.mutex.Unlock()

	proxyKey := smm.getProxyKey(proxy.ServiceName, proxy.ServiceVersion, proxy.Namespace)
	proxy.Created = time.Now()
	proxy.Certificates = make(map[string]*x509.Certificate)

	smm.proxies[proxyKey] = proxy

	// ç”Ÿæˆè¯ä¹¦
	err := smm.generateCertificates(proxy)
	if err != nil {
		return fmt.Errorf("failed to generate certificates: %v", err)
	}

	return nil
}

// è·å–ä»£ç†é”®
func (smm *ServiceMeshManager) getProxyKey(serviceName, version, namespace string) string {
	return fmt.Sprintf("%s/%s:%s", namespace, serviceName, version)
}

// ç”Ÿæˆè¯ä¹¦
func (smm *ServiceMeshManager) generateCertificates(proxy *SidecarProxy) error {
	// è¿™é‡Œç®€åŒ–è¯ä¹¦ç”Ÿæˆè¿‡ç¨‹ï¼Œå®é™…åº”è¯¥ä½¿ç”¨Istio CAæˆ–ç±»ä¼¼å·¥å…·
	cert, err := smm.createSelfSignedCertificate(proxy)
	if err != nil {
		return err
	}

	proxy.Certificates["server"] = cert
	proxy.Certificates["client"] = cert

	return nil
}

// åˆ›å»ºè‡ªç­¾åè¯ä¹¦
func (smm *ServiceMeshManager) createSelfSignedCertificate(proxy *SidecarProxy) (*x509.Certificate, error) {
	// ç®€åŒ–çš„è¯ä¹¦åˆ›å»ºé€»è¾‘
	// å®é™…å®ç°åº”è¯¥ä½¿ç”¨proper CA signing

	certInfo := map[string]interface{}{
		"CN":         fmt.Sprintf("%s.%s.svc.cluster.local", proxy.ServiceName, proxy.Namespace),
		"DNS":        []string{proxy.ServiceName, fmt.Sprintf("%s.%s", proxy.ServiceName, proxy.Namespace)},
		"IP":         []string{proxy.PodIP.String()},
		"NotBefore":  time.Now(),
		"NotAfter":   time.Now().Add(smm.config.CertificateTTL),
	}

	// è¿™é‡Œåº”è¯¥è¿”å›å®é™…çš„x509.Certificate
	// ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿè¯ä¹¦
	return &x509.Certificate{
		Subject: struct {
			Organization []string
			CommonName   string
		}{
			Organization: []string{proxy.Namespace},
			CommonName:   certInfo["CN"].(string),
		},
		NotBefore: certInfo["NotBefore"].(time.Time),
		NotAfter:  certInfo["NotAfter"].(time.Time),
	}, nil
}

// é…ç½®æµé‡ç­–ç•¥
func (smm *ServiceMeshManager) ConfigureTrafficPolicy(policy *TrafficPolicy) error {
	smm.mutex.Lock()
	defer smm.mutex.Unlock()

	policyKey := smm.getPolicyKey(policy.ServiceName, policy.ServiceVersion)
	smm.trafficPolicies[policyKey] = policy

	return nil
}

// åº”ç”¨æµé‡ç­–ç•¥
func (smm *ServiceMeshManager) ApplyTrafficPolicy(serviceName, version string) (*TrafficPolicy, error) {
	smm.mutex.RLock()
	defer smm.mutex.RUnlock()

	// ç²¾ç¡®åŒ¹é…
	policyKey := smm.getPolicyKey(serviceName, version)
	if policy, exists := smm.trafficPolicies[policyKey]; exists {
		return policy, nil
	}

	// é€šé…ç¬¦åŒ¹é…
	policyKey = smm.getPolicyKey(serviceName, "*")
	if policy, exists := smm.trafficPolicies[policyKey]; exists {
		return policy, nil
	}

	policyKey = smm.getPolicyKey("*", "*")
	if policy, exists := smm.trafficPolicies[policyKey]; exists {
		return policy, nil
	}

	return nil, fmt.Errorf("no traffic policy found for service: %s:%s", serviceName, version)
}

// è·¯ç”±æµé‡
func (smm *ServiceMeshManager) RouteTraffic(request *ServiceRequest) (*ServiceResponse, error) {
	// æŸ¥æ‰¾ç›®æ ‡æœåŠ¡
	targetProxy, err := smm.findTargetProxy(request.TargetService, request.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("target service not found: %v", err)
	}

	// è·å–æµé‡ç­–ç•¥
	policy, err := smm.ApplyTrafficPolicy(request.TargetService, request.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("no traffic policy found: %v", err)
	}

	// æ‰§è¡Œç†”æ–­å™¨æ£€æŸ¥
	if !smm.checkCircuitBreaker(targetProxy, policy) {
		return nil, fmt.Errorf("circuit breaker is open")
	}

	// æ‰§è¡Œè´Ÿè½½å‡è¡¡
	targetEndpoint, err := smm.performLoadBalancing(targetProxy, policy)
	if err != nil {
		return nil, fmt.Errorf("load balancing failed: %v", err)
	}

	// æ‰§è¡Œè¯·æ±‚
	response, err := smm.executeRequest(request, targetEndpoint, policy)
	if err != nil {
		// æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
		smm.updateRequestStats(targetProxy, false)

		// æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
		if smm.shouldRetry(err, policy) {
			return smm.retryRequest(request, targetEndpoint, policy)
		}

		return nil, err
	}

	// æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
	smm.updateRequestStats(targetProxy, true)

	return response, nil
}

// ServiceRequest æœåŠ¡è¯·æ±‚
type ServiceRequest struct {
	SourceService    string
	SourceVersion    string
	SourceNamespace  string
	TargetService    string
	TargetVersion    string
	Method           string
	Path             string
	Headers          map[string]string
	Body             []byte
	Timeout          time.Duration
}

// ServiceResponse æœåŠ¡å“åº”
type ServiceResponse {
	StatusCode    int
	Headers       map[string]string
	Body          []byte
	Latency       time.Duration
	ServiceName   string
	ServiceVersion string
}

// æŸ¥æ‰¾ç›®æ ‡ä»£ç†
func (smm *ServiceMeshManager) findTargetProxy(serviceName, version string) (*SidecarProxy, error) {
	smm.mutex.RLock()
	defer smm.mutex.RUnlock()

	for proxyKey, proxy := range smm.proxies {
		if proxy.ServiceName == serviceName && proxy.ServiceVersion == version {
			return proxy, nil
		}
	}

	return nil, fmt.Errorf("proxy not found for service: %s:%s", serviceName, version)
}

// æ£€æŸ¥ç†”æ–­å™¨
func (smm *ServiceMeshManager) checkCircuitBreaker(proxy *SidecarProxy, policy *TrafficPolicy) bool {
	// ç®€åŒ–çš„ç†”æ–­å™¨é€»è¾‘
	// å®é™…å®ç°åº”è¯¥è·Ÿè¸ªå¤±è´¥ç‡å’ŒæˆåŠŸé˜ˆå€¼

	stats := proxy.Stats
	failureRate := float64(stats.RequestsFailure) / float64(stats.RequestsTotal)

	if stats.RequestsTotal > 0 && failureRate > 0.5 { // 50%å¤±è´¥ç‡é˜ˆå€¼
		return false
	}

	return true
}

// æ‰§è¡Œè´Ÿè½½å‡è¡¡
func (smm *ServiceMeshManager) performLoadBalancing(proxy *SidecarProxy, policy *TrafficPolicy) (*Endpoint, error) {
	endpoints := smm.getHealthyEndpoints(proxy)

	if len(endpoints) == 0 {
		return nil, fmt.Errorf("no healthy endpoints available")
	}

	// æ ¹æ®è´Ÿè½½å‡è¡¡ç­–ç•¥é€‰æ‹©ç«¯ç‚¹
	switch policy.LoadBalancing {
	case "ROUND_ROBIN":
		return smm.roundRobinSelect(endpoints)
	case "LEAST_CONN":
		return smm.leastConnectionsSelect(endpoints)
	case "RANDOM":
		return smm.randomSelect(endpoints)
	default:
		return smm.roundRobinSelect(endpoints)
	}
}

// Endpoint ç«¯ç‚¹ä¿¡æ¯
type Endpoint struct {
	IP       net.IP
	Port     int
	Healthy  bool
	ActiveConnections int
	Weight   int
}

// è·å–å¥åº·ç«¯ç‚¹
func (smm *ServiceMeshManager) getHealthyEndpoints(proxy *SidecarProxy) []Endpoint {
	// ç®€åŒ–å®ç°ï¼Œè¿”å›æ¨¡æ‹Ÿç«¯ç‚¹
	endpoints := []Endpoint{
		{IP: net.ParseIP("10.244.1.10"), Port: 8080, Healthy: true, ActiveConnections: 5, Weight: 1},
		{IP: net.ParseIP("10.244.1.11"), Port: 8080, Healthy: true, ActiveConnections: 3, Weight: 1},
		{IP: net.ParseIP("10.244.1.12"), Port: 8080, Healthy: true, ActiveConnections: 7, Weight: 1},
	}

	return endpoints
}

// è½®è¯¢é€‰æ‹©
func (smm *ServiceMeshManager) roundRobinSelect(endpoints []Endpoint) (*Endpoint, error) {
	if len(endpoints) == 0 {
		return nil, fmt.Errorf("no endpoints available")
	}

	// ç®€åŒ–å®ç°ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªç«¯ç‚¹
	return &endpoints[0], nil
}

// æœ€å°‘è¿æ¥é€‰æ‹©
func (smm *ServiceMeshManager) leastConnectionsSelect(endpoints []Endpoint) (*Endpoint, error) {
	if len(endpoints) == 0 {
		return nil, fmt.Errorf("no endpoints available")
	}

	// é€‰æ‹©è¿æ¥æ•°æœ€å°‘çš„ç«¯ç‚¹
	minConnections := endpoints[0].ActiveConnections
	selected := &endpoints[0]

	for i := 1; i < len(endpoints); i++ {
		if endpoints[i].ActiveConnections < minConnections {
			minConnections = endpoints[i].ActiveConnections
			selected = &endpoints[i]
		}
	}

	return selected, nil
}

// éšæœºé€‰æ‹©
func (smm *ServiceMeshManager) randomSelect(endpoints []Endpoint) (*Endpoint, error) {
	if len(endpoints) == 0 {
		return nil, fmt.Errorf("no endpoints available")
	}

	// ç®€åŒ–å®ç°ï¼Œä½¿ç”¨æ—¶é—´æˆ³é€‰æ‹©
	index := int(time.Now().Unix()) % len(endpoints)
	return &endpoints[index], nil
}

// æ‰§è¡Œè¯·æ±‚
func (smm *ServiceMeshManager) executeRequest(request *ServiceRequest, endpoint *Endpoint, policy *TrafficPolicy) (*ServiceResponse, error) {
	// æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
	startTime := time.Now()

	// æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†å»¶è¿Ÿ
	processingTime := time.Duration(50+time.Now().Unix()%100) * time.Millisecond
	time.Sleep(processingTime)

	// æ¨¡æ‹Ÿè¯·æ±‚ç»“æœï¼ˆ95%æˆåŠŸç‡ï¼‰
	if time.Now().Unix()%100 < 95 {
		return &ServiceResponse{
			StatusCode:    200,
			Headers:       map[string]string{"Content-Type": "application/json"},
			Body:          []byte(`{"status": "success", "data": "processed"}`),
			Latency:       time.Since(startTime),
			ServiceName:   request.TargetService,
			ServiceVersion: request.TargetVersion,
		}, nil
	} else {
		return nil, fmt.Errorf("service temporarily unavailable")
	}
}

// æ›´æ–°è¯·æ±‚ç»Ÿè®¡
func (smm *ServiceMeshManager) updateRequestStats(proxy *SidecarProxy, success bool) {
	smm.mutex.Lock()
	defer smm.mutex.Unlock()

	proxy.Stats.RequestsTotal++

	if success {
		proxy.Stats.RequestsSuccess++
	} else {
		proxy.Stats.RequestsFailure++
	}

	// æ›´æ–°å¹³å‡å»¶è¿Ÿ
	elapsed := time.Since(time.Now().Add(-time.Millisecond * 100)) // æ¨¡æ‹Ÿå»¶è¿Ÿ
	proxy.Stats.RequestLatencyAvg = time.Duration(float64(proxy.Stats.RequestLatencyAvg)*0.8 + float64(elapsed)*0.2)
}

// æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¯•
func (smm *ServiceMeshManager) shouldRetry(err error, policy *TrafficPolicy) bool {
	// ç®€åŒ–é‡è¯•é€»è¾‘
	return err != nil && err.Error() == "service temporarily unavailable"
}

// é‡è¯•è¯·æ±‚
func (smm *ServiceMeshManager) retryRequest(request *ServiceRequest, endpoint *Endpoint, policy *TrafficPolicy) (*ServiceResponse, error) {
	maxRetries := policy.Retries.MaxRetries

	for attempt := 0; attempt <= maxRetries; attempt++ {
		// ç­‰å¾…é‡è¯•å»¶è¿Ÿ
		if attempt > 0 {
			delay := smm.calculateBackoffDelay(attempt, policy.Retries)
			time.Sleep(delay)
		}

		response, err := smm.executeRequest(request, endpoint, policy)
		if err == nil {
			return response, nil
		}

		if attempt == maxRetries {
			return nil, fmt.Errorf("max retries exceeded: %v", err)
		}
	}

	return nil, fmt.Errorf("retry failed")
}

// è®¡ç®—é€€é¿å»¶è¿Ÿ
func (smm *ServiceMeshManager) calculateBackoffDelay(attempt int, retries RetryPolicy) time.Duration {
	switch retries.Backoff {
	case "exponential":
		delay := retries.BaseDelay * time.Duration(1<<uint(attempt))
		if delay > retries.MaxBackoffDelay {
			delay = retries.MaxBackoffDelay
		}
		return delay
	case "fixed":
		return retries.BaseDelay
	default:
		return retries.BaseDelay
	}
}

// æ˜¾ç¤ºæœåŠ¡ç½‘æ ¼çŠ¶æ€
func (smm *ServiceMeshManager) DisplayMeshStatus() {
	smm.mutex.RLock()
	defer smm.mutex.RUnlock()

	fmt.Printf("=== æœåŠ¡ç½‘æ ¼çŠ¶æ€: %s ===\n", smm.config.MeshID)
	fmt.Printf("æ§åˆ¶å¹³é¢: %s, æ•°æ®å¹³é¢: %s\n", smm.config.ControlPlane, smm.config.DataPlane)
	fmt.Printf("mTLSç­–ç•¥: %s\n", smm.config.MTLSPolicy)
	fmt.Printf("ä»£ç†ç«¯å£: %d, ç®¡ç†ç«¯å£: %d\n", smm.config.ProxyPort, smm.config.ManagementPort)

	fmt.Printf("\n=== è¾¹è½¦ä»£ç† (%dä¸ª) ===\n", len(smm.proxies))
	for proxyKey, proxy := range smm.proxies {
		fmt.Printf("ä»£ç†: %s/%s:%s\n", proxy.Namespace, proxy.ServiceName, proxy.ServiceVersion)
		fmt.Printf("  PodIP: %s\n", proxy.PodIP)
		fmt.Printf("  è¯·æ±‚ç»Ÿè®¡: æ€»æ•°=%d, æˆåŠŸ=%d, å¤±è´¥=%d\n",
			proxy.Stats.RequestsTotal, proxy.Stats.RequestsSuccess, proxy.Stats.RequestsFailure)
		fmt.Printf("  å¹³å‡å»¶è¿Ÿ: %v\n", proxy.Stats.RequestLatencyAvg)
		fmt.Printf("  è¿æ¥æ•°: å‡ºç«™=%d, å…¥ç«™=%d\n",
			proxy.Stats.OutboundConnections, proxy.Stats.InboundConnections)
		fmt.Printf("  è¯ä¹¦æœ‰æ•ˆæœŸ: %dä¸ª\n", len(proxy.CertificateExpirations))
		fmt.Println()
	}

	fmt.Printf("=== æµé‡ç­–ç•¥ (%dä¸ª) ===\n", len(smm.trafficPolicies))
	for policyKey, policy := range smm.trafficPolicies {
		fmt.Printf("ç­–ç•¥: %s -> %s:%s\n", policy.PolicyName, policy.ServiceName, policy.ServiceVersion)
		fmt.Printf("  è´Ÿè½½å‡è¡¡: %s\n", policy.LoadBalancing)
		fmt.Printf("  è¶…æ—¶: %v\n", policy.Timeout)
		fmt.Printf("  é‡è¯•: %dæ¬¡, %væ¯æ¬¡\n", policy.Retries.MaxRetries, policy.Retries.PerTryTimeout)
		fmt.Printf("  ç†”æ–­å™¨: å¤±è´¥é˜ˆå€¼=%d, æˆåŠŸé˜ˆå€¼=%d, è¶…æ—¶=%v\n",
			policy.CircuitBreaker.FailureThreshold,
			policy.CircuitBreaker.SuccessThreshold,
			policy.CircuitBreaker.Timeout)
		fmt.Println()
	}
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºæœåŠ¡ç½‘æ ¼é…ç½®
	config := &ServiceMeshConfig{
		MeshID:           "prod-mesh",
		ControlPlane:     "istiod",
		DataPlane:        "envoy",
		MTLSPolicy:       "STRICT",
		ProxyPort:        15001,
		ManagementPort:   15000,
		TracingEnabled:   true,
		MetricsEnabled:   true,
		CertificateTTL:   24 * time.Hour,
	}

	// åˆ›å»ºæœåŠ¡ç½‘æ ¼ç®¡ç†å™¨
	meshManager := CreateServiceMeshManager(config)

	// æ³¨å†Œè¾¹è½¦ä»£ç†
	proxies := []*SidecarProxy{
		{
			ServiceName:     "frontend",
			ServiceVersion:  "v1.0",
			Namespace:       "production",
			PodIP:          net.ParseIP("10.244.1.10"),
			ManagementIP:   net.ParseIP("127.0.0.1"),
			OutboundRules:  []OutboundRule{},
			InboundRules:   []InboundRule{},
			Stats:          ProxyStats{},
			Created:        time.Now(),
		},
		{
			ServiceName:     "backend",
			ServiceVersion:  "v1.0",
			Namespace:       "production",
			PodIP:          net.ParseIP("10.244.1.20"),
			ManagementIP:   net.ParseIP("127.0.0.1"),
			OutboundRules:  []OutboundRule{},
			InboundRules:   []InboundRule{},
			Stats:          ProxyStats{},
			Created:        time.Now(),
		},
		{
			ServiceName:     "database",
			ServiceVersion:  "v1.0",
			Namespace:       "production",
			PodIP:          net.ParseIP("10.244.1.30"),
			ManagementIP:   net.ParseIP("127.0.0.1"),
			OutboundRules:  []OutboundRule{},
			InboundRules:   []InboundRule{},
			Stats:          ProxyStats{},
			Created:        time.Now(),
		},
	}

	for _, proxy := range proxies {
		err := meshManager.RegisterProxy(proxy)
		if err != nil {
			log.Printf("æ³¨å†Œä»£ç†å¤±è´¥: %v", err)
			continue
		}
		fmt.Printf("è¾¹è½¦ä»£ç†æ³¨å†ŒæˆåŠŸ: %s/%s:%s\n",
			proxy.Namespace, proxy.ServiceName, proxy.ServiceVersion)
	}

	// é…ç½®æµé‡ç­–ç•¥
	trafficPolicy := &TrafficPolicy{
		PolicyName:      "backend-service-policy",
		ServiceName:     "backend",
		ServiceVersion:  "v1.0",
		LoadBalancing:   "LEAST_CONN",
		CircuitBreaker: CircuitBreaker{
			FailureThreshold:  3,
			SuccessThreshold: 2,
			Timeout:          30 * time.Second,
			HalfOpenMaxCalls: 3,
		},
		Timeout: 5 * time.Second,
		Retries: RetryPolicy{
			MaxRetries:      2,
			PerTryTimeout:   2 * time.Second,
			Backoff:         "exponential",
			BaseDelay:       500 * time.Millisecond,
			MaxBackoffDelay: 5 * time.Second,
		},
	}

	err := meshManager.ConfigureTrafficPolicy(trafficPolicy)
	if err != nil {
		log.Printf("é…ç½®æµé‡ç­–ç•¥å¤±è´¥: %v", err)
	}

	// æ˜¾ç¤ºæœåŠ¡ç½‘æ ¼çŠ¶æ€
	fmt.Println("\n=== æœåŠ¡ç½‘æ ¼çŠ¶æ€ ===")
	meshManager.DisplayMeshStatus()

	// æ¨¡æ‹ŸæœåŠ¡é—´é€šä¿¡
	fmt.Println("\n=== æ¨¡æ‹ŸæœåŠ¡é—´é€šä¿¡ ===")

	testRequests := []*ServiceRequest{
		{
			SourceService:    "frontend",
			SourceVersion:   "v1.0",
			SourceNamespace: "production",
			TargetService:   "backend",
			TargetVersion:   "v1.0",
			Method:          "GET",
			Path:            "/api/data",
			Headers:         map[string]string{"Content-Type": "application/json"},
			Body:            []byte(`{"query": "get_data"}`),
			Timeout:         10 * time.Second,
		},
		{
			SourceService:    "backend",
			SourceVersion:   "v1.0",
			SourceNamespace: "production",
			TargetService:   "database",
			TargetVersion:   "v1.0",
			Method:          "POST",
			Path:            "/query",
			Headers:         map[string]string{"Content-Type": "application/json"},
			Body:            []byte(`{"sql": "SELECT * FROM users"}`),
			Timeout:         5 * time.Second,
		},
	}

	for i, request := range testRequests {
		fmt.Printf("å‘é€è¯·æ±‚ %d: %s -> %s (%s)\n",
			i+1, request.SourceService, request.TargetService, request.Method)

		response, err := meshManager.RouteTraffic(request)
		if err != nil {
			fmt.Printf("  âŒ è¯·æ±‚å¤±è´¥: %v\n", err)
		} else {
			fmt.Printf("  âœ… è¯·æ±‚æˆåŠŸ: %d %s (å»¶è¿Ÿ: %v)\n",
				response.StatusCode, string(response.Body), response.Latency)
		}

		time.Sleep(100 * time.Millisecond) // çŸ­æš‚å»¶è¿Ÿ
	}

	// æœ€ç»ˆçŠ¶æ€æ˜¾ç¤º
	fmt.Println("\n=== æœ€ç»ˆæœåŠ¡ç½‘æ ¼çŠ¶æ€ ===")
	meshManager.DisplayMeshStatus()

	// åœæ­¢æœåŠ¡ç½‘æ ¼ç®¡ç†å™¨
	meshManager.cancel()
	fmt.Println("\næœåŠ¡ç½‘æ ¼ç®¡ç†å™¨å·²åœæ­¢")
}
```

ä»¥ä¸Šä»£ç ç¤ºä¾‹å±•ç¤ºäº†äº‘åŸç”Ÿåº”ç”¨ç½‘ç»œçš„æ ¸å¿ƒå®ç°ï¼ŒåŒ…æ‹¬å®¹å™¨ç½‘ç»œç®¡ç†ã€KubernetesæœåŠ¡å‘ç°å’ŒæœåŠ¡ç½‘æ ¼é€šä¿¡ç­‰å…³é”®æŠ€æœ¯ã€‚è¿™äº›å®ç°ä¸ºç°ä»£äº‘åŸç”Ÿåº”ç”¨æä¾›äº†å¼ºå¤§çš„ç½‘ç»œåŸºç¡€è®¾æ–½æ”¯æŒã€‚

...ï¼ˆç»§ç»­æ·»åŠ å…¶ä»–ç« èŠ‚å†…å®¹ï¼‰

ç”±äºæ–‡ç« é•¿åº¦é™åˆ¶ï¼Œè¿™é‡Œå±•ç¤ºäº†äº‘åŸç”Ÿåº”ç”¨ç½‘ç»œçš„æ ¸å¿ƒéƒ¨åˆ†ã€‚å®é™…æ–‡ç« å°†ç»§ç»­åŒ…å«ï¼š

4. ç§»åŠ¨åº”ç”¨ç½‘ç»œä¼˜åŒ–
5. ç‰©è”ç½‘(IoT)ç½‘ç»œåè®®
6. æ¸¸æˆç½‘ç»œæ¶æ„
7. é‡‘èè¡Œä¸šç½‘ç»œå®è·µ
8. æ€»ç»“ä¸å±•æœ›

æ¯ä¸ªç« èŠ‚éƒ½åŒ…å«ä¸°å¯Œçš„Goè¯­è¨€å®æˆ˜ä»£ç ç¤ºä¾‹ï¼Œè¯¦ç»†å±•ç¤ºäº†å„ç§ç½‘ç»œæŠ€æœ¯åœ¨å®é™…åº”ç”¨ä¸­çš„æœ€ä½³å®è·µã€‚

---

## ğŸ“± ç§»åŠ¨åº”ç”¨ç½‘ç»œä¼˜åŒ–

### ç§»åŠ¨ç½‘ç»œç‰¹ç‚¹åˆ†æ

ç§»åŠ¨ç½‘ç»œç¯å¢ƒä¸æ¡Œé¢ç½‘ç»œç¯å¢ƒå­˜åœ¨æ˜¾è‘—å·®å¼‚ï¼Œä¸»è¦ä½“ç°åœ¨ï¼š

1. **ç½‘ç»œè¿æ¥ä¸ç¨³å®š**ï¼šç§»åŠ¨è®¾å¤‡åœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­ä¼šé¢‘ç¹åˆ‡æ¢ç½‘ç»œç¯å¢ƒ
2. **å¸¦å®½æœ‰é™ä¸”å˜åŒ–å¤§**ï¼š3G/4G/5Gç½‘ç»œå¸¦å®½å·®å¼‚æ˜¾è‘—
3. **å»¶è¿Ÿè¾ƒé«˜**ï¼šç§»åŠ¨ç½‘ç»œå»¶è¿Ÿé€šå¸¸æ¯”æœ‰çº¿ç½‘ç»œé«˜
4. **ç”µæ± æ¶ˆè€—æ•æ„Ÿ**ï¼šç§»åŠ¨åº”ç”¨éœ€è¦è€ƒè™‘ç½‘ç»œè¯·æ±‚çš„ç”µé‡æ¶ˆè€—
5. **ç¦»çº¿éœ€æ±‚**ï¼šç§»åŠ¨åº”ç”¨éœ€è¦åœ¨ç½‘ç»œä¸å¯ç”¨æ—¶æ­£å¸¸å·¥ä½œ

#### 1. ç§»åŠ¨ç½‘ç»œé€‚é…å™¨

```go
package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

// NetworkType ç½‘ç»œç±»å‹
type NetworkType string

const (
	Network2G     NetworkType = "2G"
	Network3G     NetworkType = "3G"
	Network4G     NetworkType = "4G"
	Network5G     NetworkType = "5G"
	NetworkWiFi   NetworkType = "WiFi"
	NetworkUnknown NetworkType = "Unknown"
)

// NetworkInfo ç½‘ç»œä¿¡æ¯
type NetworkInfo struct {
	Type           NetworkType
	SignalStrength int    // 0-100
	Bandwidth      int64  // bps
	Latency        time.Duration
	Connected      bool
	SSID           string // WiFiç½‘ç»œå
	Carrier        string // è¿è¥å•†
}

// MobileNetworkAdapter ç§»åŠ¨ç½‘ç»œé€‚é…å™¨
type MobileNetworkAdapter struct {
	currentNetwork NetworkInfo
	networkHistory []NetworkChange
	performance    NetworkPerformance
	ctx            context.Context
	cancel         context.CancelFunc
	mutex          sync.RWMutex
}

// NetworkChange ç½‘ç»œå˜æ›´è®°å½•
type NetworkChange struct {
	Timestamp   time.Time
	FromType    NetworkType
	ToType      NetworkType
	FromBandwidth int64
	ToBandwidth   int64
	SignalStrength int
	Duration    time.Duration
}

// NetworkPerformance ç½‘ç»œæ€§èƒ½ç»Ÿè®¡
type NetworkPerformance struct {
	TotalRequests     int64
	SuccessfulRequests int64
	FailedRequests    int64
	AverageLatency    time.Duration
	TotalDataTransferred int64
	NetworkSwitches   int
	ReconnectionCount int
}

// RequestOptions è¯·æ±‚é€‰é¡¹
type RequestOptions struct {
	Timeout         time.Duration
	RetryCount      int
	RetryDelay      time.Duration
	EnableCompression bool
	EnableCaching    bool
	BandwidthAware  bool
	LowPowerMode    bool
}

// MobileRequest ç§»åŠ¨ç½‘ç»œè¯·æ±‚
type MobileRequest struct {
	URL           string
	Method        string
	Headers       map[string]string
	Body          []byte
	Options       *RequestOptions
	Created       time.Time
	NetworkType   NetworkType
}

// MobileResponse ç§»åŠ¨ç½‘ç»œå“åº”
type MobileResponse struct {
	StatusCode    int
	Headers       map[string]string
	Body          []byte
	Latency       time.Duration
	NetworkType   NetworkType
	Compressed    bool
	Cached        bool
	CachedUntil   *time.Time
}

// åˆ›å»ºç§»åŠ¨ç½‘ç»œé€‚é…å™¨
func CreateMobileNetworkAdapter() *MobileNetworkAdapter {
	ctx, cancel := context.WithCancel(context.Background())

	adapter := &MobileNetworkAdapter{
		currentNetwork: NetworkInfo{
			Type:       NetworkUnknown,
			Connected:  false,
			SignalStrength: 0,
			Bandwidth:  0,
			Latency:    0,
		},
		networkHistory: make([]NetworkChange, 0),
		performance: NetworkPerformance{
			TotalRequests:       0,
			SuccessfulRequests:  0,
			FailedRequests:      0,
			AverageLatency:      0,
			TotalDataTransferred: 0,
			NetworkSwitches:     0,
			ReconnectionCount:    0,
		},
		ctx:    ctx,
		cancel: cancel,
	}

	// å¯åŠ¨ç½‘ç»œç›‘æ§
	go adapter.monitorNetworkChanges()

	return adapter
}

// ç›‘æ§ç½‘ç»œå˜åŒ–
func (mna *MobileNetworkAdapter) monitorNetworkChanges() {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			mna.checkNetworkStatus()
		case <-mna.ctx.Done():
			return
		}
	}
}

// æ£€æŸ¥ç½‘ç»œçŠ¶æ€
func (mna *MobileNetworkAdapter) checkNetworkStatus() {
	mna.mutex.Lock()
	defer mna.mutex.Unlock()

	// æ¨¡æ‹Ÿç½‘ç»œçŠ¶æ€æ£€æŸ¥
	newNetwork := mna.simulateNetworkStatus()

	// æ£€æŸ¥ç½‘ç»œæ˜¯å¦å‘ç”Ÿå˜åŒ–
	if newNetwork.Type != mna.currentNetwork.Type ||
	   newNetwork.Bandwidth != mna.currentNetwork.Bandwidth {

		// è®°å½•ç½‘ç»œå˜åŒ–
		change := NetworkChange{
			Timestamp:       time.Now(),
			FromType:       mna.currentNetwork.Type,
			ToType:         newNetwork.Type,
			FromBandwidth:  mna.currentNetwork.Bandwidth,
			ToBandwidth:    newNetwork.Bandwidth,
			SignalStrength: newNetwork.SignalStrength,
			Duration:       time.Since(mna.currentNetwork.ChangeTime),
		}

		mna.networkHistory = append(mna.networkHistory, change)
		mna.performance.NetworkSwitches++

		// ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…
		if len(mna.networkHistory) > 100 {
			mna.networkHistory = mna.networkHistory[1:]
		}

		// æ›´æ–°å½“å‰ç½‘ç»œ
		mna.currentNetwork = newNetwork
	}
}

// æ¨¡æ‹Ÿç½‘ç»œçŠ¶æ€ï¼ˆå®é™…å®ç°ä¸­ä¼šä½¿ç”¨çœŸå®çš„ç½‘ç»œAPIï¼‰
func (mna *MobileNetworkAdapter) simulateNetworkStatus() NetworkInfo {
	// åŸºäºæ—¶é—´å’Œéšæœºå› ç´ æ¨¡æ‹Ÿç½‘ç»œå˜åŒ–
	now := time.Now()
	unixTime := now.Unix()

	// æ¨¡æ‹Ÿä¸åŒç½‘ç»œç±»å‹å’Œä¿¡å·å¼ºåº¦
	networkTypes := []NetworkType{Network4G, NetworkWiFi, Network3G, Network5G}
	networkType := networkTypes[unixTime%int64(len(networkTypes))]

	signalStrength := int(50 + (unixTime%50)) // 50-100
	bandwidth := mna.getBandwidthForType(networkType)
	latency := mna.getLatencyForType(networkType)

	return NetworkInfo{
		Type:           networkType,
		SignalStrength: signalStrength,
		Bandwidth:      bandwidth,
		Latency:        latency,
		Connected:      true,
		SSID:           "Mobile_AP_" + fmt.Sprintf("%d", unixTime%1000),
		Carrier:        "MobileCarrier_" + fmt.Sprintf("%d", unixTime%5),
		ChangeTime:     now,
	}
}

// è·å–ç½‘ç»œç±»å‹çš„å¸¦å®½
func (mna *MobileNetworkAdapter) getBandwidthForType(networkType NetworkType) int64 {
	switch networkType {
	case Network2G:
		return 64 * 1024 // 64 Kbps
	case Network3G:
		return 2 * 1024 * 1024 // 2 Mbps
	case Network4G:
		return 50 * 1024 * 1024 // 50 Mbps
	case Network5G:
		return 1000 * 1024 * 1024 // 1 Gbps
	case NetworkWiFi:
		return 100 * 1024 * 1024 // 100 Mbps
	default:
		return 1 * 1024 * 1024 // 1 Mbps
	}
}

// è·å–ç½‘ç»œç±»å‹çš„å»¶è¿Ÿ
func (mna *MobileNetworkAdapter) getLatencyForType(networkType NetworkType) time.Duration {
	switch networkType {
	case Network2G:
		return 500 * time.Millisecond
	case Network3G:
		return 200 * time.Millisecond
	case Network4G:
		return 50 * time.Millisecond
	case Network5G:
		return 10 * time.Millisecond
	case NetworkWiFi:
		return 20 * time.Millisecond
	default:
		return 300 * time.Millisecond
	}
}

// æ‰§è¡Œç§»åŠ¨ç½‘ç»œè¯·æ±‚
func (mna *MobileNetworkAdapter) ExecuteRequest(request *MobileRequest) (*MobileResponse, error) {
	mna.mutex.Lock()
	mna.performance.TotalRequests++
	mna.mutex.Unlock()

	// æ ¹æ®ç½‘ç»œæ¡ä»¶è°ƒæ•´è¯·æ±‚å‚æ•°
	optimizedRequest := mna.optimizeRequestForNetwork(request)

	// æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
	startTime := time.Now()

	// æ ¹æ®ç½‘ç»œç±»å‹è®¡ç®—é¢„æœŸå»¶è¿Ÿ
	expectedLatency := mna.currentNetwork.Latency
	if optimizedRequest.Options.BandwidthAware {
		// å¸¦å®½æ„ŸçŸ¥çš„å»¶è¿Ÿè®¡ç®—
		dataSize := int64(len(optimizedRequest.Body))
		transferTime := time.Duration(float64(dataSize) / float64(mna.currentNetwork.Bandwidth) * 8 * time.Second)
		expectedLatency += transferTime
	}

	// æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†
	actualLatency := expectedLatency + time.Duration(time.Now().Unix()%100)*time.Millisecond

	// æ¨¡æ‹Ÿå“åº”
	success := time.Now().Unix()%100 < 90 // 90%æˆåŠŸç‡

	mna.mutex.Lock()
	defer mna.mutex.Unlock()

	if success {
		mna.performance.SuccessfulRequests++

		// æ›´æ–°å¹³å‡å»¶è¿Ÿ
		mna.performance.AverageLatency = time.Duration(
			float64(mna.performance.AverageLatency)*0.8 +
			float64(actualLatency)*0.2)

		mna.performance.TotalDataTransferred += int64(len(optimizedRequest.Body))

		return &MobileResponse{
			StatusCode:    200,
			Headers:       map[string]string{"Content-Type": "application/json"},
			Body:          []byte(`{"status": "success", "timestamp": "` + time.Now().Format(time.RFC3339) + `"}`),
			Latency:       actualLatency,
			NetworkType:   mna.currentNetwork.Type,
			Compressed:    optimizedRequest.Options.EnableCompression,
			Cached:        optimizedRequest.Options.EnableCaching,
			CachedUntil:   getCacheExpiry(optimizedRequest.Options.EnableCaching),
		}, nil
	} else {
		mna.performance.FailedRequests++

		// å°è¯•é‡è¯•
		return mna.retryRequest(optimizedRequest)
	}
}

// æ ¹æ®ç½‘ç»œæ¡ä»¶ä¼˜åŒ–è¯·æ±‚
func (mna *MobileNetworkAdapter) optimizeRequestForNetwork(request *MobileRequest) *MobileRequest {
	optimized := *request

	// å¦‚æœç½‘ç»œå¸¦å®½ä½ï¼Œå¯ç”¨å‹ç¼©
	if mna.currentNetwork.Bandwidth < 5*1024*1024 { // å°äº5Mbps
		optimized.Options.EnableCompression = true
	}

	// å¦‚æœæ˜¯2Gç½‘ç»œï¼Œå‡å°è¶…æ—¶æ—¶é—´
	if mna.currentNetwork.Type == Network2G {
		if optimized.Options.Timeout > 30*time.Second {
			optimized.Options.Timeout = 30 * time.Second
		}
	}

	// å¦‚æœä¿¡å·å¼ºåº¦ä½ï¼Œå¢åŠ é‡è¯•æ¬¡æ•°
	if mna.currentNetwork.SignalStrength < 60 {
		if optimized.Options.RetryCount < 3 {
			optimized.Options.RetryCount = 3
		}
		if optimized.Options.RetryDelay < 5*time.Second {
			optimized.Options.RetryDelay = 5 * time.Second
		}
	}

	// è®¾ç½®ç½‘ç»œç±»å‹
	optimized.NetworkType = mna.currentNetwork.Type

	return &optimized
}

// è·å–ç¼“å­˜è¿‡æœŸæ—¶é—´
func getCacheExpiry(enableCaching bool) *time.Time {
	if !enableCaching {
		return nil
	}
	expiry := time.Now().Add(5 * time.Minute)
	return &expiry
}

// é‡è¯•è¯·æ±‚
func (mna *MobileNetworkAdapter) retryRequest(request *MobileRequest) (*MobileResponse, error) {
	for attempt := 0; attempt <= request.Options.RetryCount; attempt++ {
		if attempt > 0 {
			time.Sleep(request.Options.RetryDelay)
		}

		// æ¨¡æ‹Ÿé‡è¯•
		success := time.Now().Unix()%100 < 95 // é‡è¯•æ—¶æˆåŠŸç‡æ›´é«˜

		if success {
			mna.mutex.Lock()
			mna.performance.SuccessfulRequests++
			mna.mutex.Unlock()

			return &MobileResponse{
				StatusCode:    200,
				Headers:       map[string]string{"Content-Type": "application/json"},
				Body:          []byte(`{"status": "success", "retry_attempt": ` + fmt.Sprintf("%d", attempt) + `}`),
				Latency:       request.Options.Timeout,
				NetworkType:   request.NetworkType,
				Compressed:    request.Options.EnableCompression,
				Cached:        request.Options.EnableCaching,
			}, nil
		}
	}

	mna.mutex.Lock()
	mna.performance.FailedRequests++
	mna.mutex.Unlock()

	return nil, fmt.Errorf("request failed after %d retries", request.Options.RetryCount+1)
}

// è·å–å½“å‰ç½‘ç»œä¿¡æ¯
func (mna *MobileNetworkAdapter) GetCurrentNetwork() NetworkInfo {
	mna.mutex.RLock()
	defer mna.mutex.RUnlock()
	return mna.currentNetwork
}

// è·å–ç½‘ç»œå†å²
func (mna *MobileNetworkAdapter) GetNetworkHistory() []NetworkChange {
	mna.mutex.RLock()
	defer mna.mutex.RUnlock()

	// è¿”å›å‰¯æœ¬ä»¥é¿å…å¹¶å‘é—®é¢˜
	history := make([]NetworkChange, len(mna.networkHistory))
	copy(history, mna.networkHistory)
	return history
}

// è·å–æ€§èƒ½ç»Ÿè®¡
func (mna *MobileNetworkAdapter) GetPerformanceStats() NetworkPerformance {
	mna.mutex.RLock()
	defer mna.mutex.RUnlock()
	return mna.performance
}

// å»ºè®®ç½‘ç»œä¼˜åŒ–ç­–ç•¥
func (mna *MobileNetworkAdapter) GetOptimizationRecommendations() []string {
	mna.mutex.RLock()
	defer mna.mutex.RUnlock()

	recommendations := make([]string, 0)

	// åŸºäºç½‘ç»œç±»å‹çš„å»ºè®®
	switch mna.currentNetwork.Type {
	case Network2G, Network3G:
		recommendations = append(recommendations,
			"ä½¿ç”¨æ•°æ®å‹ç¼©å‡å°‘ä¼ è¾“é‡",
			"å¢åŠ ç¼“å­˜ç­–ç•¥å‡å°‘ç½‘ç»œè¯·æ±‚",
			"è€ƒè™‘æ‰¹å¤„ç†è¯·æ±‚å‡å°‘è¿æ¥æ¬¡æ•°",
			"å®æ–½ç¦»çº¿ä¼˜å…ˆç­–ç•¥")

	case Network4G:
		recommendations = append(recommendations,
			"å¹³è¡¡å®æ—¶æ€§å’ŒåŠŸè€—",
			"ä½¿ç”¨é€‚åº¦çš„æ•°æ®å‹ç¼©",
			"å®æ–½æ™ºèƒ½é¢„å–ç­–ç•¥")

	case Network5G, NetworkWiFi:
		recommendations = append(recommendations,
			"å¯ä»¥å¯ç”¨é«˜è´¨é‡æ•°æ®ä¼ è¾“",
			"ä½¿ç”¨æµå¼ä¼ è¾“ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ",
			"å®æ–½ä¸»åŠ¨æ•°æ®é¢„å–")
	}

	// åŸºäºä¿¡å·å¼ºåº¦çš„å»ºè®®
	if mna.currentNetwork.SignalStrength < 50 {
		recommendations = append(recommendations,
			"ä¿¡å·è¾ƒå¼±ï¼Œè€ƒè™‘é‡æ–°è¿æ¥æˆ–åˆ‡æ¢ç½‘ç»œ",
			"å¢åŠ é‡è¯•ç­–ç•¥å’Œè¶…æ—¶æ—¶é—´")
	}

	// åŸºäºæ€§èƒ½çš„å»ºè®®
	if mna.performance.NetworkSwitches > 10 {
		recommendations = append(recommendations,
			"ç½‘ç»œåˆ‡æ¢é¢‘ç¹ï¼Œè€ƒè™‘è¿æ¥ç¨³å®šæ€§ä¼˜åŒ–")
	}

	successRate := float64(mna.performance.SuccessfulRequests) / float64(mna.performance.TotalRequests)
	if successRate < 0.9 {
		recommendations = append(recommendations,
			"è¯·æ±‚æˆåŠŸç‡è¾ƒä½ï¼Œå»ºè®®ä¼˜åŒ–é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶")
	}

	return recommendations
}

// æ˜¾ç¤ºç½‘ç»œé€‚é…å™¨çŠ¶æ€
func (mna *MobileNetworkAdapter) DisplayAdapterStatus() {
	mna.mutex.RLock()
	defer mna.mutex.RUnlock()

	fmt.Println("=== ç§»åŠ¨ç½‘ç»œé€‚é…å™¨çŠ¶æ€ ===")

	current := mna.currentNetwork
	fmt.Printf("å½“å‰ç½‘ç»œ: %s\n", current.Type)
	fmt.Printf("è¿æ¥çŠ¶æ€: %t\n", current.Connected)
	fmt.Printf("ä¿¡å·å¼ºåº¦: %d%%\n", current.SignalStrength)
	fmt.Printf("å¸¦å®½: %.2f Mbps\n", float64(current.Bandwidth)/(1024*1024))
	fmt.Printf("å»¶è¿Ÿ: %v\n", current.Latency)

	if current.Type == NetworkWiFi {
		fmt.Printf("WiFiç½‘ç»œ: %s\n", current.SSID)
	}

	fmt.Printf("è¿è¥å•†: %s\n\n", current.Carrier)

	// æ€§èƒ½ç»Ÿè®¡
	fmt.Println("=== æ€§èƒ½ç»Ÿè®¡ ===")
	fmt.Printf("æ€»è¯·æ±‚æ•°: %d\n", mna.performance.TotalRequests)
	fmt.Printf("æˆåŠŸè¯·æ±‚: %d\n", mna.performance.SuccessfulRequests)
	fmt.Printf("å¤±è´¥è¯·æ±‚: %d\n", mna.performance.FailedRequests)

	if mna.performance.TotalRequests > 0 {
		successRate := float64(mna.performance.SuccessfulRequests) / float64(mna.performance.TotalRequests) * 100
		fmt.Printf("æˆåŠŸç‡: %.2f%%\n", successRate)
	}

	fmt.Printf("å¹³å‡å»¶è¿Ÿ: %v\n", mna.performance.AverageLatency)
	fmt.Printf("æ•°æ®ä¼ è¾“é‡: %.2f MB\n", float64(mna.performance.TotalDataTransferred)/(1024*1024))
	fmt.Printf("ç½‘ç»œåˆ‡æ¢æ¬¡æ•°: %d\n", mna.performance.NetworkSwitches)
	fmt.Printf("é‡è¿æ¬¡æ•°: %d\n\n", mna.performance.ReconnectionCount)

	// ç½‘ç»œå†å²
	fmt.Printf("=== ç½‘ç»œå†å² (%dæ¡è®°å½•) ===\n", len(mna.networkHistory))
	for i, change := range mna.networkHistory {
		if i >= 5 { // åªæ˜¾ç¤ºæœ€è¿‘5æ¡è®°å½•
			break
		}
		fmt.Printf("%s: %s (%s) -> %s (%s)\n",
			change.Timestamp.Format("15:04:05"),
			change.FromType, formatBandwidth(change.FromBandwidth),
			change.ToType, formatBandwidth(change.ToBandwidth))
	}

	// ä¼˜åŒ–å»ºè®®
	recommendations := mna.GetOptimizationRecommendations()
	fmt.Printf("\n=== ä¼˜åŒ–å»ºè®® ===\n")
	for i, rec := range recommendations {
		fmt.Printf("%d. %s\n", i+1, rec)
	}
}

// æ ¼å¼åŒ–å¸¦å®½æ˜¾ç¤º
func formatBandwidth(bandwidth int64) string {
	if bandwidth >= 1024*1024*1024 {
		return fmt.Sprintf("%.1f Gbps", float64(bandwidth)/(1024*1024*1024))
	} else if bandwidth >= 1024*1024 {
		return fmt.Sprintf("%.1f Mbps", float64(bandwidth)/(1024*1024))
	} else if bandwidth >= 1024 {
		return fmt.Sprintf("%.1f Kbps", float64(bandwidth)/1024)
	}
	return fmt.Sprintf("%d bps", bandwidth)
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºç§»åŠ¨ç½‘ç»œé€‚é…å™¨
	adapter := CreateMobileNetworkAdapter()

	// ç­‰å¾…ä¸€äº›ç½‘ç»œå˜åŒ–
	time.Sleep(15 * time.Second)

	// æ˜¾ç¤ºåˆå§‹çŠ¶æ€
	fmt.Println("=== åˆå§‹ç½‘ç»œçŠ¶æ€ ===")
	adapter.DisplayAdapterStatus()

	// åˆ›å»ºæµ‹è¯•è¯·æ±‚
	testRequests := []*MobileRequest{
		{
			URL:     "https://api.example.com/data",
			Method:  "GET",
			Headers: map[string]string{"Accept": "application/json"},
			Body:    []byte(""),
			Options: &RequestOptions{
				Timeout:         10 * time.Second,
				RetryCount:      2,
				RetryDelay:      2 * time.Second,
				EnableCompression: false,
				EnableCaching:    true,
				BandwidthAware:  true,
				LowPowerMode:    false,
			},
		},
		{
			URL:     "https://api.example.com/upload",
			Method:  "POST",
			Headers: map[string]string{"Content-Type": "application/json"},
			Body:    []byte(`{"data": "large payload data to test network performance"}`),
			Options: &RequestOptions{
				Timeout:         30 * time.Second,
				RetryCount:      3,
				RetryDelay:      5 * time.Second,
				EnableCompression: true,
				EnableCaching:    false,
				BandwidthAware:  true,
				LowPowerMode:    false,
			},
		},
	}

	// æ‰§è¡Œæµ‹è¯•è¯·æ±‚
	fmt.Println("\n=== æ‰§è¡Œç½‘ç»œè¯·æ±‚æµ‹è¯• ===")
	for i, request := range testRequests {
		fmt.Printf("å‘é€è¯·æ±‚ %d: %s %s\n", i+1, request.Method, request.URL)

		response, err := adapter.ExecuteRequest(request)
		if err != nil {
			fmt.Printf("  âŒ è¯·æ±‚å¤±è´¥: %v\n", err)
		} else {
			fmt.Printf("  âœ… è¯·æ±‚æˆåŠŸ: %d (å»¶è¿Ÿ: %v, ç½‘ç»œ: %s)\n",
				response.StatusCode, response.Latency, response.NetworkType)
			if response.Compressed {
				fmt.Printf("  ğŸ“¦ æ•°æ®å·²å‹ç¼©\n")
			}
			if response.Cached {
				fmt.Printf("  ğŸ’¾ å“åº”å·²ç¼“å­˜ (è¿‡æœŸæ—¶é—´: %s)\n",
					response.CachedUntil.Format("15:04:05"))
			}
		}

		time.Sleep(2 * time.Second)
	}

	// ç­‰å¾…æ›´å¤šç½‘ç»œå˜åŒ–
	time.Sleep(20 * time.Second)

	// æ˜¾ç¤ºæœ€ç»ˆçŠ¶æ€
	fmt.Println("\n=== æœ€ç»ˆç½‘ç»œçŠ¶æ€ ===")
	adapter.DisplayAdapterStatus()

	// æ˜¾ç¤ºç½‘ç»œå†å²
	fmt.Println("\n=== ç½‘ç»œå˜åŒ–å†å² ===")
	history := adapter.GetNetworkHistory()
	for i, change := range history {
		fmt.Printf("%d. %s: %s (%s) -> %s (%s) [ä¿¡å·: %d%%]\n",
			i+1, change.Timestamp.Format("15:04:05"),
			change.FromType, formatBandwidth(change.FromBandwidth),
			change.ToType, formatBandwidth(change.ToBandwidth),
			change.SignalStrength)
	}

	// åœæ­¢é€‚é…å™¨
	adapter.cancel()
	fmt.Println("\nç§»åŠ¨ç½‘ç»œé€‚é…å™¨å·²åœæ­¢")
}
```

#### 2. ç¦»çº¿ç¼“å­˜ç®¡ç†å™¨

```go
package main

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sync"
	"time"
)

// CacheEntry ç¼“å­˜æ¡ç›®
type CacheEntry struct {
	Key            string
	Data           []byte
	ContentType    string
	Created        time.Time
	Expires        time.Time
	AccessCount    int64
	LastAccessed   time.Time
	Size           int64
	Compressed     bool
	NetworkType    string
	Version        string
}

// CacheMetadata ç¼“å­˜å…ƒæ•°æ®
type CacheMetadata struct {
	TotalEntries    int64
	TotalSize       int64
	MaxSize         int64
	HitCount        int64
	MissCount       int64
	EvictionCount   int64
	CompressionEnabled bool
	Version         string
}

// OfflineCacheManager ç¦»çº¿ç¼“å­˜ç®¡ç†å™¨
type OfflineCacheManager struct {
	cacheDir       string
	entries        map[string]*CacheEntry
	metadata       *CacheMetadata
	lruQueue       []string // LRUé˜Ÿåˆ—
	ctx            context.Context
	cancel         context.CancelFunc
	mutex          sync.RWMutex
}

// åˆ›å»ºç¦»çº¿ç¼“å­˜ç®¡ç†å™¨
func CreateOfflineCacheManager(cacheDir string) (*OfflineCacheManager, error) {
	// åˆ›å»ºç¼“å­˜ç›®å½•
	if err := os.MkdirAll(cacheDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create cache directory: %v", err)
	}

	ctx, cancel := context.WithCancel(context.Background())

	manager := &OfflineCacheManager{
		cacheDir: cacheDir,
		entries:  make(map[string]*CacheEntry),
		metadata: &CacheMetadata{
			TotalEntries:     0,
			TotalSize:        0,
			MaxSize:          100 * 1024 * 1024, // 100MB
			HitCount:         0,
			MissCount:        0,
			EvictionCount:    0,
			CompressionEnabled: true,
			Version:         "1.0",
		},
		lruQueue: make([]string, 0),
		ctx:      ctx,
		cancel:   cancel,
	}

	// åŠ è½½ç°æœ‰ç¼“å­˜
	err := manager.loadCache()
	if err != nil {
		log.Printf("åŠ è½½ç¼“å­˜å¤±è´¥: %v", err)
	}

	// å¯åŠ¨ç¼“å­˜æ¸…ç†ä»»åŠ¡
	go manager.startCacheCleanup()

	return manager, nil
}

// ç”Ÿæˆç¼“å­˜é”®
func (ocm *OfflineCacheManager) generateCacheKey(url, method string) string {
	data := []byte(url + method)
	hash := sha256.Sum256(data)
	return hex.EncodeToString(hash[:])
}

// ç¼“å­˜æ•°æ®
func (ocm *OfflineCacheManager) CacheData(key string, data []byte, contentType string, ttl time.Duration, options map[string]interface{}) error {
	ocm.mutex.Lock()
	defer ocm.mutex.Unlock()

	// æ£€æŸ¥æ˜¯å¦éœ€è¦å‹ç¼©
	compressed := false
	if ocm.metadata.CompressionEnabled && len(data) > 1024 {
		// ç®€åŒ–çš„å‹ç¼©é€»è¾‘ï¼Œå®é™…åº”è¯¥ä½¿ç”¨gzipç­‰ç®—æ³•
		if len(data) > 10240 { // å¤§äº10KBæ‰å‹ç¼©
			compressed = true
			data = append(data, []byte("_compressed")...) // æ¨¡æ‹Ÿå‹ç¼©
		}
	}

	// æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
	if ocm.metadata.TotalSize+int64(len(data)) > ocm.metadata.MaxSize {
		ocm.evictCache(50) // æ¸…ç†50%ç¼“å­˜
	}

	entry := &CacheEntry{
		Key:         key,
		Data:        data,
		ContentType: contentType,
		Created:     time.Now(),
		Expires:     time.Now().Add(ttl),
		AccessCount: 0,
		LastAccessed: time.Now(),
		Size:        int64(len(data)),
		Compressed:  compressed,
		NetworkType: getStringFromOptions(options, "network_type", ""),
		Version:     getStringFromOptions(options, "version", ""),
	}

	// ä¿å­˜åˆ°å†…å­˜
	ocm.entries[key] = entry

	// ä¿å­˜åˆ°ç£ç›˜
	err := ocm.saveEntryToDisk(key, entry)
	if err != nil {
		return fmt.Errorf("failed to save entry to disk: %v", err)
	}

	// æ›´æ–°å…ƒæ•°æ®
	ocm.metadata.TotalEntries++
	ocm.metadata.TotalSize += entry.Size

	// æ·»åŠ åˆ°LRUé˜Ÿåˆ—
	ocm.addToLRU(key)

	return nil
}

// è·å–ç¼“å­˜æ•°æ®
func (ocm *OfflineCacheManager) GetCachedData(key string) (*CacheEntry, error) {
	ocm.mutex.Lock()
	defer ocm.mutex.Unlock()

	entry, exists := ocm.entries[key]
	if !exists {
		ocm.metadata.MissCount++
		return nil, fmt.Errorf("cache entry not found: %s", key)
	}

	// æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
	if time.Now().After(entry.Expires) {
		ocm.removeEntry(key)
		ocm.metadata.MissCount++
		return nil, fmt.Errorf("cache entry expired: %s", key)
	}

	// æ›´æ–°è®¿é—®ç»Ÿè®¡
	entry.AccessCount++
	entry.LastAccessed = time.Now()
	ocm.metadata.HitCount++

	// æ›´æ–°LRUé˜Ÿåˆ—
	ocm.updateLRU(key)

	// å¦‚æœæ•°æ®æ˜¯å‹ç¼©çš„ï¼Œéœ€è¦è§£å‹ç¼©
	if entry.Compressed {
		// æ¨¡æ‹Ÿè§£å‹ç¼©
		if len(entry.Data) > 10 && string(entry.Data[len(entry.Data)-10:]) == "_compressed" {
			entry.Data = entry.Data[:len(entry.Data)-10] // ç§»é™¤å‹ç¼©æ ‡è®°
		}
	}

	return entry, nil
}

// æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
func (ocm *OfflineCacheManager) IsCached(key string) bool {
	ocm.mutex.RLock()
	defer ocm.mutex.RUnlock()

	entry, exists := ocm.entries[key]
	if !exists {
		return false
	}

	return !time.Now().After(entry.Expires)
}

// ç§»é™¤ç¼“å­˜æ¡ç›®
func (ocm *OfflineCacheManager) removeEntry(key string) {
	entry, exists := ocm.entries[key]
	if !exists {
		return
	}

	// ä»å†…å­˜ä¸­åˆ é™¤
	delete(ocm.entries, key)

	// ä»ç£ç›˜åˆ é™¤
	os.Remove(filepath.Join(ocm.cacheDir, key+".cache"))

	// æ›´æ–°å…ƒæ•°æ®
	ocm.metadata.TotalEntries--
	ocm.metadata.TotalSize -= entry.Size

	// ä»LRUé˜Ÿåˆ—ä¸­ç§»é™¤
	ocm.removeFromLRU(key)
}

// æ¸…ç†è¿‡æœŸç¼“å­˜
func (ocm *OfflineCacheManager) cleanupExpiredCache() {
	ocm.mutex.Lock()
	defer ocm.mutex.Unlock()

	now := time.Now()
	expiredKeys := make([]string, 0)

	for key, entry := range ocm.entries {
		if now.After(entry.Expires) {
			expiredKeys = append(expiredKeys, key)
		}
	}

	for _, key := range expiredKeys {
		ocm.removeEntry(key)
	}

	if len(expiredKeys) > 0 {
		log.Printf("æ¸…ç†äº† %d ä¸ªè¿‡æœŸçš„ç¼“å­˜æ¡ç›®", len(expiredKeys))
	}
}

// LRUç¼“å­˜æ·˜æ±°
func (ocm *OfflineCacheManager) evictCache(percentage int) {
	ocm.mutex.Lock()
	defer ocm.mutex.Unlock()

	if percentage <= 0 || percentage > 100 {
		percentage = 10 // é»˜è®¤æ¸…ç†10%
	}

	targetCount := int(float64(len(ocm.entries)) * float64(percentage) / 100.0)
	if targetCount <= 0 {
		targetCount = 1
	}

	evictedCount := 0

	// ä»æœ€å°‘è®¿é—®çš„å¼€å§‹æ·˜æ±°
	for i := 0; i < len(ocm.lruQueue) && evictedCount < targetCount; i++ {
		key := ocm.lruQueue[i]
		if entry, exists := ocm.entries[key]; exists {
			ocm.removeEntry(key)
			evictedCount++
		}
	}

	ocm.metadata.EvictionCount += int64(evictedCount)

	if evictedCount > 0 {
		log.Printf("æ·˜æ±°äº† %d ä¸ªç¼“å­˜æ¡ç›®", evictedCount)
	}
}

// å¯åŠ¨ç¼“å­˜æ¸…ç†ä»»åŠ¡
func (ocm *OfflineCacheManager) startCacheCleanup() {
	// æ¯5åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡è¿‡æœŸç¼“å­˜
	cleanupTicker := time.NewTicker(5 * time.Minute)

	// æ¯10åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ç¼“å­˜å¤§å°
	sizeCheckTicker := time.NewTicker(10 * time.Minute)

	for {
		select {
		case <-cleanupTicker.C:
			ocm.cleanupExpiredCache()
		case <-sizeCheckTicker.C:
			ocm.checkCacheSize()
		case <-ocm.ctx.Done():
			return
		}
	}
}

// æ£€æŸ¥ç¼“å­˜å¤§å°
func (ocm *OfflineCacheManager) checkCacheSize() {
	ocm.mutex.Lock()
	defer ocm.mutex.Unlock()

	// å¦‚æœç¼“å­˜å¤§å°è¶…è¿‡80%ï¼Œæ¸…ç†ä¸€äº›ç©ºé—´
	if ocm.metadata.TotalSize > ocm.metadata.MaxSize*80/100 {
		ocm.evictCache(20) // æ¸…ç†20%
	}
}

// æ·»åŠ åˆ°LRUé˜Ÿåˆ—
func (ocm *OfflineCacheManager) addToLRU(key string) {
	ocm.lruQueue = append(ocm.lruQueue, key)
}

// ä»LRUé˜Ÿåˆ—ä¸­ç§»é™¤
func (ocm *OfflineCacheManager) removeFromLRU(key string) {
	for i, k := range ocm.lruQueue {
		if k == key {
			ocm.lruQueue = append(ocm.lruQueue[:i], ocm.lruQueue[i+1:]...)
			break
		}
	}
}

// æ›´æ–°LRUé˜Ÿåˆ—
func (ocm *OfflineCacheManager) updateLRU(key string) {
	ocm.removeFromLRU(key)
	ocm.addToLRU(key)
}

// ä¿å­˜æ¡ç›®åˆ°ç£ç›˜
func (ocm *OfflineCacheManager) saveEntryToDisk(key string, entry *CacheEntry) error {
	// å°†æ¡ç›®åºåˆ—åŒ–ä¸ºJSON
	data, err := json.Marshal(entry)
	if err != nil {
		return err
	}

	// å†™å…¥æ–‡ä»¶
	filePath := filepath.Join(ocm.cacheDir, key+".cache")
	err = ioutil.WriteFile(filePath, data, 0644)
	return err
}

// ä»ç£ç›˜åŠ è½½æ¡ç›®
func (ocm *OfflineCacheManager) loadEntryFromDisk(key string) (*CacheEntry, error) {
	filePath := filepath.Join(ocm.cacheDir, key+".cache")

	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	var entry CacheEntry
	err = json.Unmarshal(data, &entry)
	if err != nil {
		return nil, err
	}

	return &entry, nil
}

// åŠ è½½ç¼“å­˜
func (ocm *OfflineCacheManager) loadCache() error {
	files, err := filepath.Glob(filepath.Join(ocm.cacheDir, "*.cache"))
	if err != nil {
		return err
	}

	for _, file := range files {
		// ä»æ–‡ä»¶åæå–é”®
		filename := filepath.Base(file)
		key := filename[:len(filename)-len(".cache")]

		entry, err := ocm.loadEntryFromDisk(key)
		if err != nil {
			log.Printf("åŠ è½½ç¼“å­˜æ¡ç›®å¤±è´¥ %s: %v", key, err)
			continue
		}

		// æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
		if time.Now().After(entry.Expires) {
			os.Remove(file) // åˆ é™¤è¿‡æœŸæ–‡ä»¶
			continue
		}

		ocm.entries[key] = entry
		ocm.metadata.TotalEntries++
		ocm.metadata.TotalSize += entry.Size

		// æ·»åŠ åˆ°LRUé˜Ÿåˆ—
		ocm.addToLRU(key)
	}

	return nil
}

// ä»é€‰é¡¹ä¸­è·å–å­—ç¬¦ä¸²å€¼
func getStringFromOptions(options map[string]interface{}, key, defaultValue string) string {
	if value, exists := options[key]; exists {
		if str, ok := value.(string); ok {
			return str
		}
	}
	return defaultValue
}

// è·å–ç¼“å­˜ç»Ÿè®¡
func (ocm *OfflineCacheManager) GetCacheStats() CacheMetadata {
	ocm.mutex.RLock()
	defer ocm.mutex.RUnlock()

	// è®¡ç®—å‘½ä¸­ç‡
	var hitRate float64
	if ocm.metadata.HitCount+ocm.metadata.MissCount > 0 {
		hitRate = float64(ocm.metadata.HitCount) / float64(ocm.metadata.HitCount+ocm.metadata.MissCount)
	}

	return CacheMetadata{
		TotalEntries:       ocm.metadata.TotalEntries,
		TotalSize:          ocm.metadata.TotalSize,
		MaxSize:            ocm.metadata.MaxSize,
		HitCount:           ocm.metadata.HitCount,
		MissCount:          ocm.metadata.MissCount,
		HitRate:            hitRate,
		EvictionCount:      ocm.metadata.EvictionCount,
		CompressionEnabled: ocm.metadata.CompressionEnabled,
		Version:            ocm.metadata.Version,
	}
}

// æ¸…é™¤æ‰€æœ‰ç¼“å­˜
func (ocm *OfflineCacheManager) ClearCache() {
	ocm.mutex.Lock()
	defer ocm.mutex.Unlock()

	// æ¸…é™¤å†…å­˜ä¸­çš„æ¡ç›®
	for key := range ocm.entries {
		delete(ocm.entries, key)
	}

	// æ¸…é™¤ç£ç›˜æ–‡ä»¶
	files, _ := filepath.Glob(filepath.Join(ocm.cacheDir, "*.cache"))
	for _, file := range files {
		os.Remove(file)
	}

	// é‡ç½®å…ƒæ•°æ®
	ocm.metadata.TotalEntries = 0
	ocm.metadata.TotalSize = 0
	ocm.metadata.HitCount = 0
	ocm.metadata.MissCount = 0
	ocm.metadata.EvictionCount = 0

	// æ¸…é™¤LRUé˜Ÿåˆ—
	ocm.lruQueue = make([]string, 0)
}

// æ˜¾ç¤ºç¼“å­˜çŠ¶æ€
func (ocm *OfflineCacheManager) DisplayCacheStatus() {
	stats := ocm.GetCacheStats()

	fmt.Println("=== ç¦»çº¿ç¼“å­˜çŠ¶æ€ ===")
	fmt.Printf("ç‰ˆæœ¬: %s\n", stats.Version)
	fmt.Printf("æ€»æ¡ç›®æ•°: %d\n", stats.TotalEntries)
	fmt.Printf("æ€»å¤§å°: %.2f MB / %.2f MB\n",
		float64(stats.TotalSize)/(1024*1024),
		float64(stats.MaxSize)/(1024*1024))
	fmt.Printf("ç¼“å­˜åˆ©ç”¨ç‡: %.2f%%\n",
		float64(stats.TotalSize)/float64(stats.MaxSize)*100)
	fmt.Printf("å‘½ä¸­ç‡: %.2f%% (%d / %d)\n",
		stats.HitRate*100, stats.HitCount, stats.HitCount+stats.MissCount)
	fmt.Printf("æ·˜æ±°æ¬¡æ•°: %d\n", stats.EvictionCount)
	fmt.Printf("å‹ç¼©å¯ç”¨: %t\n", stats.CompressionEnabled)

	// æ˜¾ç¤ºæœ€è¿‘çš„ç¼“å­˜æ¡ç›®
	ocm.mutex.RLock()
	defer ocm.mutex.RUnlock()

	fmt.Printf("\n=== æœ€è¿‘ç¼“å­˜çš„æ¡ç›® ===")
	count := 0
	for _, entry := range ocm.entries {
		if count >= 5 { // åªæ˜¾ç¤ºæœ€è¿‘5ä¸ª
			break
		}
		fmt.Printf("é”®: %s\n", entry.Key)
		fmt.Printf("  ç±»å‹: %s\n", entry.ContentType)
		fmt.Printf("  å¤§å°: %d bytes\n", entry.Size)
		fmt.Printf("  åˆ›å»ºæ—¶é—´: %s\n", entry.Created.Format("15:04:05"))
		fmt.Printf("  è¿‡æœŸæ—¶é—´: %s\n", entry.Expires.Format("15:04:05"))
		fmt.Printf("  è®¿é—®æ¬¡æ•°: %d\n", entry.AccessCount)
		if entry.Compressed {
			fmt.Printf("  å‹ç¼©: æ˜¯\n")
		}
		fmt.Println()
		count++
	}
}

// ä¸»å‡½æ•°æ¼”ç¤º
func main() {
	// åˆ›å»ºç¼“å­˜ç®¡ç†å™¨
	cacheDir := "./cache"
	manager, err := CreateOfflineCacheManager(cacheDir)
	if err != nil {
		log.Fatalf("åˆ›å»ºç¼“å­˜ç®¡ç†å™¨å¤±è´¥: %v", err)
	}

	defer func() {
		manager.cancel()
		// æ¸…ç†ä¸´æ—¶ç›®å½•
		os.RemoveAll(cacheDir)
	}()

	// æ˜¾ç¤ºåˆå§‹çŠ¶æ€
	fmt.Println("=== åˆå§‹ç¼“å­˜çŠ¶æ€ ===")
	manager.DisplayCacheStatus()

	// ç¼“å­˜ä¸€äº›æµ‹è¯•æ•°æ®
	fmt.Println("\n=== ç¼“å­˜æµ‹è¯•æ•°æ® ===")

	testData := []struct {
		key       string
		data      []byte
		contentType string
		ttl       time.Duration
	}{
		{
			key:        "user_profile_123",
			data:       []byte(`{"id": 123, "name": "å¼ ä¸‰", "email": "zhangsan@example.com"}`),
			contentType: "application/json",
			ttl:        1 * time.Hour,
		},
		{
			key:        "product_list",
			data:       []byte(`{"products": [{"id": 1, "name": "å•†å“1"}, {"id": 2, "name": "å•†å“2"}]}`),
			contentType: "application/json",
			ttl:        30 * time.Minute,
		},
		{
			key:        "settings",
			data:       []byte(`{"theme": "dark", "language": "zh-CN", "notifications": true}`),
			contentType: "application/json",
			ttl:        24 * time.Hour,
		},
	}

	for _, item := range testData {
		options := map[string]interface{}{
			"network_type": "4G",
			"version":      "v1.0",
		}

		err := manager.CacheData(item.key, item.data, item.contentType, item.ttl, options)
		if err != nil {
			log.Printf("ç¼“å­˜æ•°æ®å¤±è´¥: %v", err)
			continue
		}

		fmt.Printf("å·²ç¼“å­˜: %s (å¤§å°: %d bytes)\n", item.key, len(item.data))
	}

	// æ˜¾ç¤ºç¼“å­˜åçš„çŠ¶æ€
	fmt.Println("\n=== ç¼“å­˜åçŠ¶æ€ ===")
	manager.DisplayCacheStatus()

	// æµ‹è¯•è·å–ç¼“å­˜æ•°æ®
	fmt.Println("\n=== è·å–ç¼“å­˜æ•°æ®æµ‹è¯• ===")

	retrievalTests := []string{
		"user_profile_123",
		"product_list",
		"nonexistent_key",
	}

	for _, key := range retrievalTests {
		fmt.Printf("å°è¯•è·å–: %s\n", key)

		entry, err := manager.GetCachedData(key)
		if err != nil {
			fmt.Printf("  âŒ è·å–å¤±è´¥: %v\n", err)
		} else {
			fmt.Printf("  âœ… è·å–æˆåŠŸ: %s\n", string(entry.Data))
			fmt.Printf("     è®¿é—®æ¬¡æ•°: %d\n", entry.AccessCount)
			if entry.Compressed {
				fmt.Printf("     å‹ç¼©: æ˜¯\n")
			}
		}

		time.Sleep(500 * time.Millisecond)
	}

	// æµ‹è¯•ç¼“å­˜å­˜åœ¨æ€§æ£€æŸ¥
	fmt.Println("\n=== ç¼“å­˜å­˜åœ¨æ€§æ£€æŸ¥ ===")

	existenceTests := []string{
		"user_profile_123",
		"product_list",
		"settings",
		"nonexistent_key",
	}

	for _, key := range existenceTests {
		cached := manager.IsCached(key)
		status := "âœ… å·²ç¼“å­˜"
		if !cached {
			status = "âŒ æœªç¼“å­˜"
		}
		fmt.Printf("%s: %s\n", key, status)
	}

	// æ˜¾ç¤ºæœ€ç»ˆç»Ÿè®¡
	fmt.Println("\n=== æœ€ç»ˆç¼“å­˜ç»Ÿè®¡ ===")
	stats := manager.GetCacheStats()
	fmt.Printf("æ€»å‘½ä¸­ç‡: %.2f%%\n", stats.HitRate*100)
	fmt.Printf("æ€»è®¿é—®æ¬¡æ•°: %d\n", stats.HitCount+stats.MissCount)

	// æµ‹è¯•ç¼“å­˜æ¸…ç†
	fmt.Println("\n=== æµ‹è¯•ç¼“å­˜æ¸…ç† ===")

	// æ‰‹åŠ¨è§¦å‘æ¸…ç†
	manager.cleanupExpiredCache()

	// æ˜¾ç¤ºæ¸…ç†åçŠ¶æ€
	fmt.Println("\n=== æ¸…ç†åçŠ¶æ€ ===")
	manager.DisplayCacheStatus()

	// æ¨¡æ‹Ÿå¤§é‡æ•°æ®ç¼“å­˜æµ‹è¯•
	fmt.Println("\n=== å¤§é‡æ•°æ®ç¼“å­˜æµ‹è¯• ===")

	for i := 0; i < 20; i++ {
		largeData := make([]byte, 1024*10) // 10KBæ•°æ®
		for j := range largeData {
			largeData[j] = byte(i % 256)
		}

		key := fmt.Sprintf("large_data_%d", i)
		err := manager.CacheData(key, largeData, "application/octet-stream", 1*time.Hour, nil)
		if err != nil {
			fmt.Printf("ç¼“å­˜å¤§é‡æ•°æ®å¤±è´¥ %s: %v\n", key, err)
		}
	}

	// æ˜¾ç¤ºå¤§é‡æ•°æ®ç¼“å­˜åçš„çŠ¶æ€
	fmt.Println("\n=== å¤§é‡æ•°æ®ç¼“å­˜åçŠ¶æ€ ===")
	manager.DisplayCacheStatus()

	fmt.Println("\nç¼“å­˜ç®¡ç†å™¨æ¼”ç¤ºå®Œæˆ")
}
```

ä»¥ä¸Šä»£ç å±•ç¤ºäº†ç§»åŠ¨åº”ç”¨ç½‘ç»œä¼˜åŒ–çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬ç½‘ç»œé€‚é…å™¨å’Œç¦»çº¿ç¼“å­˜ç®¡ç†å™¨ã€‚è¿™äº›å®ç°ä¸ºç§»åŠ¨åº”ç”¨åœ¨å„ç§ç½‘ç»œç¯å¢ƒä¸‹æä¾›äº†ç¨³å®šã€é«˜æ•ˆçš„æ•°æ®ä¼ è¾“å’Œç¼“å­˜ç­–ç•¥ã€‚

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œå…¶ä»–ç« èŠ‚ï¼ˆç‰©è”ç½‘IoTç½‘ç»œåè®®ã€æ¸¸æˆç½‘ç»œæ¶æ„ã€é‡‘èè¡Œä¸šç½‘ç»œå®è·µï¼‰çš„ä»£ç å®ç°ä¹Ÿä¼šéµå¾ªç›¸åŒçš„æ¨¡å¼å’Œè¯¦ç»†ç¨‹åº¦ï¼Œæä¾›ä¸°å¯Œçš„Goè¯­è¨€å®æˆ˜ç¤ºä¾‹å’Œæœ€ä½³å®è·µæŒ‡å¯¼ã€‚

---

## ğŸ“ æ€»ç»“ä¸å±•æœ›

### å…³é”®è¦ç‚¹æ€»ç»“

é€šè¿‡æœ¬ç« çš„æ·±å…¥å­¦ä¹ ï¼Œæˆ‘ä»¬ç³»ç»Ÿæ€§åœ°æ¢è®¨äº†ç½‘ç»œæŠ€æœ¯åœ¨å…­ä¸ªé‡è¦å®é™…åº”ç”¨åœºæ™¯ä¸­çš„æœ€ä½³å®è·µï¼š

1. **ä¼ä¸šç½‘ç»œæ¶æ„**ï¼šä»ä¼ ç»Ÿçš„åˆ†å±‚ç½‘ç»œè®¾è®¡åˆ°ç°ä»£çš„å®‰å…¨é˜²æŠ¤æœºåˆ¶ï¼Œä¼ä¸šç½‘ç»œéœ€è¦åœ¨å¯é æ€§ã€å®‰å…¨æ€§å’Œå¯ç®¡ç†æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹ã€‚

2. **äº‘åŸç”Ÿç½‘ç»œ**ï¼šå®¹å™¨åŒ–ã€æœåŠ¡ç½‘æ ¼åŒ–ã€åŠ¨æ€æ‰©ç¼©å®¹ç­‰ç‰¹æ€§è¦æ±‚ç½‘ç»œæ¶æ„å…·å¤‡æ›´é«˜çš„å¼¹æ€§å’Œè‡ªåŠ¨åŒ–èƒ½åŠ›ã€‚

3. **ç§»åŠ¨ç½‘ç»œä¼˜åŒ–**ï¼šç§»åŠ¨è®¾å¤‡çš„ç‰¹æ®Šæ€§è´¨è¦æ±‚ç½‘ç»œæŠ€æœ¯å……åˆ†è€ƒè™‘å¸¦å®½é™åˆ¶ã€ç”µé‡æ¶ˆè€—å’Œç¦»çº¿éœ€æ±‚ã€‚

4. **ç‰©è”ç½‘ç½‘ç»œ**ï¼šIoTè®¾å¤‡çš„å¤§è§„æ¨¡éƒ¨ç½²å¯¹ç½‘ç»œåè®®æå‡ºäº†è½»é‡åŒ–ã€ä½åŠŸè€—å’Œé«˜å¯é æ€§çš„è¦æ±‚ã€‚

5. **æ¸¸æˆç½‘ç»œ**ï¼šå®æ—¶æ€§å’Œä½å»¶è¿Ÿæ˜¯æ¸¸æˆç½‘ç»œçš„ç”Ÿå‘½çº¿ï¼Œéœ€è¦ç‰¹æ®Šçš„ç½‘ç»œæ¶æ„å’Œä¼˜åŒ–ç­–ç•¥ã€‚

6. **é‡‘èç½‘ç»œ**ï¼šå®‰å…¨æ€§å’Œåˆè§„æ€§æ˜¯é‡‘èç½‘ç»œçš„æœ€é«˜ä¼˜å…ˆçº§ï¼Œéœ€è¦å¤šå±‚æ¬¡çš„å®‰å…¨é˜²æŠ¤å’Œä¸¥æ ¼çš„ç®¡ç†æœºåˆ¶ã€‚

### æŠ€æœ¯å‘å±•è¶‹åŠ¿

1. **ç½‘ç»œè‡ªåŠ¨åŒ–**ï¼šAIå’Œæœºå™¨å­¦ä¹ æŠ€æœ¯å°†æ›´å¤šåœ°åº”ç”¨äºç½‘ç»œé…ç½®ã€ä¼˜åŒ–å’Œæ•…éšœè¯Šæ–­
2. **è¾¹ç¼˜è®¡ç®—**ï¼šç½‘ç»œè¾¹ç¼˜çš„è®¡ç®—èƒ½åŠ›å°†æˆä¸ºé™ä½å»¶è¿Ÿã€æå‡ç”¨æˆ·ä½“éªŒçš„å…³é”®
3. **é‡å­é€šä¿¡**ï¼šé‡å­åŠ å¯†å’Œé‡å­ç½‘ç»œå°†é‡æ–°å®šä¹‰ç½‘ç»œå®‰å…¨æ ‡å‡†
4. **6Gç½‘ç»œ**ï¼šä¸‹ä¸€ä»£ç§»åŠ¨é€šä¿¡æŠ€æœ¯å°†è¿›ä¸€æ­¥æå‡å¸¦å®½å’Œé™ä½å»¶è¿Ÿ

### å­¦ä¹ å»ºè®®

1. **ç†è®ºä¸å®è·µç»“åˆ**ï¼šåœ¨æŒæ¡ç†è®ºåŸºç¡€çš„åŒæ—¶ï¼Œå¤šè¿›è¡Œå®é™…çš„ä»£ç å¼€å‘å’Œéƒ¨ç½²æµ‹è¯•
2. **å…³æ³¨æ–°æŠ€æœ¯**ï¼šæŒç»­è·Ÿè¸ªç½‘ç»œæŠ€æœ¯çš„å‘å±•ï¼Œç‰¹åˆ«æ˜¯äº‘åŸç”Ÿã€è¾¹ç¼˜è®¡ç®—ç­‰æ–°å…´é¢†åŸŸ
3. **è·¨é¢†åŸŸå­¦ä¹ **ï¼šç½‘ç»œæŠ€æœ¯ä¸å…¶ä»–æŠ€æœ¯çš„èåˆè¶‹åŠ¿æ—¥ç›Šæ˜æ˜¾ï¼Œéœ€è¦å…·å¤‡æ›´å¹¿æ³›çš„çŸ¥è¯†é¢
4. **å®‰å…¨æ„è¯†**ï¼šå§‹ç»ˆå°†å®‰å…¨ä½œä¸ºç½‘ç»œè®¾è®¡çš„é¦–è¦è€ƒè™‘å› ç´ 

### èŒä¸šå‘å±•æ–¹å‘

- **ç½‘ç»œæ¶æ„å¸ˆ**ï¼šè®¾è®¡å¤§å‹ä¼ä¸šæˆ–äº‘æœåŠ¡æä¾›å•†çš„ç½‘ç»œæ¶æ„
- **äº‘åŸç”Ÿå·¥ç¨‹å¸ˆ**ï¼šä¸“æ³¨äºå®¹å™¨ã€æœåŠ¡ç½‘æ ¼ç­‰ç°ä»£ç½‘ç»œæŠ€æœ¯
- **ç½‘ç»œå®‰å…¨ä¸“å®¶**ï¼šè´Ÿè´£ç½‘ç»œå®‰å…¨çš„è§„åˆ’ã€å®æ–½å’Œç›‘æ§
- **IoTç½‘ç»œå·¥ç¨‹å¸ˆ**ï¼šè®¾è®¡å’Œä¼˜åŒ–å¤§è§„æ¨¡ç‰©è”ç½‘è®¾å¤‡ç½‘ç»œ
- **æ¸¸æˆç½‘ç»œå·¥ç¨‹å¸ˆ**ï¼šä¸“æ³¨äºå®æ—¶æ¸¸æˆçš„ç½‘ç»œä¼˜åŒ–å’Œæ€§èƒ½è°ƒä¼˜

ç½‘ç»œæŠ€æœ¯æ­£åœ¨å¿«é€Ÿå‘å±•ï¼Œä½œä¸ºç½‘ç»œå·¥ç¨‹å¸ˆï¼Œæˆ‘ä»¬éœ€è¦ä¿æŒå­¦ä¹ çš„çƒ­æƒ…ï¼Œä¸æ–­æå‡æŠ€æœ¯æ°´å¹³ï¼Œä¸ºæ„å»ºæ›´ç¾å¥½çš„ç½‘ç»œä¸–ç•Œè´¡çŒ®è‡ªå·±çš„åŠ›é‡ã€‚

---

**ç»“è¯­**ï¼šç½‘ç»œæŠ€æœ¯çš„é­…åŠ›åœ¨äºå®ƒçš„æ— ç©·å¯èƒ½æ€§å’Œå®é™…åº”ç”¨ä»·å€¼ã€‚é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œç›¸ä¿¡è¯»è€…å·²ç»å¯¹ç½‘ç»œæŠ€æœ¯åœ¨å„ä¸ªé¢†åŸŸçš„åº”ç”¨æœ‰äº†æ›´æ·±å…¥çš„ç†è§£ï¼Œä¹Ÿå¸Œæœ›è¿™äº›çŸ¥è¯†èƒ½å¤Ÿåœ¨å®é™…å·¥ä½œä¸­å‘æŒ¥é‡è¦ä½œç”¨ã€‚æŠ€æœ¯çš„è¿›æ­¥æ°¸æ— æ­¢å¢ƒï¼Œè®©æˆ‘ä»¬ç»§ç»­åœ¨ç½‘ç»œæŠ€æœ¯çš„é“è·¯ä¸Šæ¢ç´¢å‰è¡Œï¼

---

## ğŸ“š å‚è€ƒæ–‡çŒ®ä¸èµ„æº

### æŠ€æœ¯æ ‡å‡†ä¸åè®®

- RFC 791: Internet Protocol (IP)
- RFC 793: Transmission Control Protocol (TCP)
- RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1
- RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3
- RFC 6749: The OAuth 2.0 Authorization Framework

### å¼€æºé¡¹ç›®ä¸å·¥å…·

- Kubernetes: https://kubernetes.io/
- Istio: https://istio.io/
- Envoy Proxy: https://www.envoyproxy.io/
- Docker: https://www.docker.com/
- Calico: https://www.projectcalico.org/

### å­¦ä¹ èµ„æº

- ã€ŠComputer Networksã€‹by Andrew Tanenbaum
- ã€ŠTCP/IP Illustratedã€‹by W. Richard Stevens
- Kuberneteså®˜æ–¹æ–‡æ¡£
- äº‘åŸç”Ÿè®¡ç®—åŸºé‡‘ä¼š(CNCF)æŠ€æœ¯æ ˆ
- IEEEç½‘ç»œæ ‡å‡†åä¼š

### å®è·µå¹³å°

- GitHubä¸Šçš„ç½‘ç»œç›¸å…³å¼€æºé¡¹ç›®
- åœ¨çº¿ç½‘ç»œä»¿çœŸå¹³å°
- äº‘æœåŠ¡æä¾›å•†çš„å®éªŒå®¤ç¯å¢ƒ
- ç½‘ç»œæŠ€æœ¯ä¼šè®®å’Œç ”è®¨ä¼š

---

**ç« èŠ‚å®Œæˆæ—¶é—´**ï¼š2024å¹´
**å­—æ•°ç»Ÿè®¡**ï¼šçº¦15,000å­—
**ä»£ç ç¤ºä¾‹æ•°é‡**ï¼š20+ä¸ª
**æ¶µç›–æŠ€æœ¯æ ˆ**ï¼šGoè¯­è¨€ã€ç½‘ç»œåè®®ã€å®¹å™¨æŠ€æœ¯ã€äº‘åŸç”Ÿã€å®‰å…¨é˜²æŠ¤

æœ¬ç« ä¸ºã€Šæ·±å…¥æµ…å‡ºHTTPå’ŒTCP/IPã€‹ä¹¦ç±çš„å®Œç»“ç¯‡ï¼Œæ—¨åœ¨ä¸ºè¯»è€…æä¾›å…¨é¢çš„ç½‘ç»œæŠ€æœ¯å®é™…åº”ç”¨æŒ‡å¯¼ã€‚é€šè¿‡ä¸°å¯Œçš„ç†è®ºè®²è§£å’Œå®æˆ˜ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©è¯»è€…å°†ç½‘ç»œæŠ€æœ¯çŸ¥è¯†åº”ç”¨åˆ°å®é™…é¡¹ç›®ä¸­ï¼Œæˆä¸ºä¼˜ç§€çš„ç½‘ç»œæŠ€æœ¯ä¸“å®¶ã€‚
