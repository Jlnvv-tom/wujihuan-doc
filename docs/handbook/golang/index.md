# GoLang 学习

## 第1章、写给未来的Go程序员——为什么选择Go？

1. Go语言的诞生背景与设计目标
2. Go的核心特性：简洁、高效、并发
3. Go在云原生与微服务中的优势
4. Go与其他语言的对比分析
5. Go的生态系统与社区发展
6. 成功案例：Docker、Kubernetes与etcd
7. 开发环境初体验：从安装到运行
8. 如何高效学习Go语言：路径建议

## 第2章、从环境搭建到程序运行：第一个 Go 程序之旅

1. 安装Go开发环境与版本管理
2. 设置GOPATH与模块模式
3. 使用go run与go build构建程序
4. 程序结构解析：包、导入、主函数
5. 注释与代码可读性规范
6. 使用Go Modules初始化项目
7. 常见错误与调试入门

## 第3章、基础语法——变量、常量与数据类型

1. 变量的声明方式：var与短声明
2. 常量定义与iota枚举机制
3. Go的基本数据类型体系
4. 零值机制与类型默认值
5. 类型推断与显式转换
6. 短变量声明的作用域规则
7. 命名规范：驼峰与导出规则
8. 代码格式化与go fmt工具

## 第4章、简单数据类型详解——整型、浮点、布尔与字符串

1. 整型类型：int、int8、int32、int64
2. 无符号整型与内存占用
3. 浮点数与精度问题
4. 布尔类型与逻辑运算
5. 字符串的不可变性与底层结构
6. UTF-8编码与rune、byte区别
7. 字符串常用操作与性能注意点
8. 类型别名与自定义类型

## 第5章、控制结构——条件、循环与跳转语句

1. if语句与条件表达式
2. switch语句：表达式与类型选择
3. for循环的多种写法
4. 无限循环与循环控制
5. break、continue、goto的使用场景
6. 标签语句与跨层跳转
7. 条件判断中的常见陷阱
8. 控制结构的性能与可读性

## 第6章、函数的艺术——定义、多返回值与闭包

1. 函数定义与参数传递机制
2. 多返回值与错误处理惯例
3. 命名返回值的使用技巧
4. 函数作为一等公民：函数值
5. 匿名函数与立即执行函数
6. 闭包的定义与变量捕获机制
7. 闭包中的变量生命周期问题
8. 函数式编程思想在Go中的应用

## 第7章、复合类型——数组、切片与映射（slice和map）

1. 数组：固定长度的序列结构
2. 切片：动态数组的底层实现
3. 切片的扩容策略与性能分析
4. 切片的共享内存与拷贝问题
5. map的定义与基本操作
6. map的并发安全与sync.Map
7. 遍历map与顺序不确定性
8. 复合类型的内存布局与性能优

## 第8章、指针与内存管理——理解Go的底层机制

1. 指针的基本语法与使用场景
2. 指针的零值与空指针风险
3. new函数与内存分配
4. make与new的区别对比
5. 栈内存与堆内存的分配机制
6. 逃逸分析：变量何时分配在堆上
7. 指针作为方法接收者的意义
8. 内存管理与垃圾回收机制简介

## 第9章、结构体与方法——面向对象的Go式实现

1. 结构体的定义与字段组织
2. 结构体的零值与初始化方式
3. 匿名字段与结构体嵌入
4. 组合优于继承：Go的复用哲学
5. 方法的定义与接收者类型选择
6. 值接收者与指针接收者的区别
7. 方法集与接口实现的关系
8. 结构体标签（struct tag）的使用

# 第10章、接口与多态——Go语言的抽象之美

一、接口的定义与隐式实现机制
二、空接口interface{}与泛型替代
三、类型断言与类型安全检查
四、类型选择（type switch）的使用
五、接口的组合与扩展性设计
六、鸭子类型与Go的多态实现
七、error接口的设计哲学
八、接口在大型项目中的分层应

# 第11章、错误处理与异常机制——构建健壮程序

一、error接口与错误处理惯例
二、自定义错误类型与错误包装
三、使用fmt.Errorf与%w格式化
四、defer语句的执行时机与用途
五、panic与recover的异常恢复机制
六、defer、panic、recover协同使用
七、错误日志记录与上下文传递

# 第12章、并发编程基石——goroutine与channel

一、goroutine：轻量级线程模型
二、Go调度器与GMP模型简介
三、channel的创建与基本操作
四、无缓冲channel与同步通信
五、有缓冲channel与异步解耦
六、单向channel与接口约束
七、关闭channel与迭代处理
八、并发安全与数据竞争检测
