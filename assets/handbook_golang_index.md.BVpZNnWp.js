import{_ as i,c as a,o as e,aj as o}from"./chunks/framework.CynFBi0q.js";const b=JSON.parse('{"title":"GoLang 学习","description":"","frontmatter":{},"headers":[],"relativePath":"handbook/golang/index.md","filePath":"handbook/golang/index.md","lastUpdated":1768837259000}'),r={name:"handbook/golang/index.md"};function n(h,l,t,c,d,s){return e(),a("div",null,[...l[0]||(l[0]=[o('<h1 id="golang-学习" tabindex="-1">GoLang 学习 <a class="header-anchor" href="#golang-学习" aria-label="Permalink to “GoLang 学习”">​</a></h1><h2 id="第1章、写给未来的go程序员——为什么选择go" tabindex="-1">第1章、写给未来的Go程序员——为什么选择Go？ <a class="header-anchor" href="#第1章、写给未来的go程序员——为什么选择go" aria-label="Permalink to “第1章、写给未来的Go程序员——为什么选择Go？”">​</a></h2><ol><li>Go语言的诞生背景与设计目标</li><li>Go的核心特性：简洁、高效、并发</li><li>Go在云原生与微服务中的优势</li><li>Go与其他语言的对比分析</li><li>Go的生态系统与社区发展</li><li>成功案例：Docker、Kubernetes与etcd</li><li>开发环境初体验：从安装到运行</li><li>如何高效学习Go语言：路径建议</li></ol><h2 id="第2章、从环境搭建到程序运行-第一个-go-程序之旅" tabindex="-1">第2章、从环境搭建到程序运行：第一个 Go 程序之旅 <a class="header-anchor" href="#第2章、从环境搭建到程序运行-第一个-go-程序之旅" aria-label="Permalink to “第2章、从环境搭建到程序运行：第一个 Go 程序之旅”">​</a></h2><ol><li>安装Go开发环境与版本管理</li><li>设置GOPATH与模块模式</li><li>使用go run与go build构建程序</li><li>程序结构解析：包、导入、主函数</li><li>注释与代码可读性规范</li><li>使用Go Modules初始化项目</li><li>常见错误与调试入门</li></ol><h2 id="第3章、基础语法——变量、常量与数据类型" tabindex="-1">第3章、基础语法——变量、常量与数据类型 <a class="header-anchor" href="#第3章、基础语法——变量、常量与数据类型" aria-label="Permalink to “第3章、基础语法——变量、常量与数据类型”">​</a></h2><ol><li>变量的声明方式：var与短声明</li><li>常量定义与iota枚举机制</li><li>Go的基本数据类型体系</li><li>零值机制与类型默认值</li><li>类型推断与显式转换</li><li>短变量声明的作用域规则</li><li>命名规范：驼峰与导出规则</li><li>代码格式化与go fmt工具</li></ol><h2 id="第4章、简单数据类型详解——整型、浮点、布尔与字符串" tabindex="-1">第4章、简单数据类型详解——整型、浮点、布尔与字符串 <a class="header-anchor" href="#第4章、简单数据类型详解——整型、浮点、布尔与字符串" aria-label="Permalink to “第4章、简单数据类型详解——整型、浮点、布尔与字符串”">​</a></h2><ol><li>整型类型：int、int8、int32、int64</li><li>无符号整型与内存占用</li><li>浮点数与精度问题</li><li>布尔类型与逻辑运算</li><li>字符串的不可变性与底层结构</li><li>UTF-8编码与rune、byte区别</li><li>字符串常用操作与性能注意点</li><li>类型别名与自定义类型</li></ol><h2 id="第5章、控制结构——条件、循环与跳转语句" tabindex="-1">第5章、控制结构——条件、循环与跳转语句 <a class="header-anchor" href="#第5章、控制结构——条件、循环与跳转语句" aria-label="Permalink to “第5章、控制结构——条件、循环与跳转语句”">​</a></h2><ol><li>if语句与条件表达式</li><li>switch语句：表达式与类型选择</li><li>for循环的多种写法</li><li>无限循环与循环控制</li><li>break、continue、goto的使用场景</li><li>标签语句与跨层跳转</li><li>条件判断中的常见陷阱</li><li>控制结构的性能与可读性</li></ol><h2 id="第6章、函数的艺术——定义、多返回值与闭包" tabindex="-1">第6章、函数的艺术——定义、多返回值与闭包 <a class="header-anchor" href="#第6章、函数的艺术——定义、多返回值与闭包" aria-label="Permalink to “第6章、函数的艺术——定义、多返回值与闭包”">​</a></h2><ol><li>函数定义与参数传递机制</li><li>多返回值与错误处理惯例</li><li>命名返回值的使用技巧</li><li>函数作为一等公民：函数值</li><li>匿名函数与立即执行函数</li><li>闭包的定义与变量捕获机制</li><li>闭包中的变量生命周期问题</li><li>函数式编程思想在Go中的应用</li></ol><h2 id="第7章、复合类型——数组、切片与映射-slice和map" tabindex="-1">第7章、复合类型——数组、切片与映射（slice和map） <a class="header-anchor" href="#第7章、复合类型——数组、切片与映射-slice和map" aria-label="Permalink to “第7章、复合类型——数组、切片与映射（slice和map）”">​</a></h2><ol><li>数组：固定长度的序列结构</li><li>切片：动态数组的底层实现</li><li>切片的扩容策略与性能分析</li><li>切片的共享内存与拷贝问题</li><li>map的定义与基本操作</li><li>map的并发安全与sync.Map</li><li>遍历map与顺序不确定性</li><li>复合类型的内存布局与性能优</li></ol><h2 id="第8章、指针与内存管理——理解go的底层机制" tabindex="-1">第8章、指针与内存管理——理解Go的底层机制 <a class="header-anchor" href="#第8章、指针与内存管理——理解go的底层机制" aria-label="Permalink to “第8章、指针与内存管理——理解Go的底层机制”">​</a></h2><ol><li>指针的基本语法与使用场景</li><li>指针的零值与空指针风险</li><li>new函数与内存分配</li><li>make与new的区别对比</li><li>栈内存与堆内存的分配机制</li><li>逃逸分析：变量何时分配在堆上</li><li>指针作为方法接收者的意义</li><li>内存管理与垃圾回收机制简介</li></ol><h2 id="第9章、结构体与方法——面向对象的go式实现" tabindex="-1">第9章、结构体与方法——面向对象的Go式实现 <a class="header-anchor" href="#第9章、结构体与方法——面向对象的go式实现" aria-label="Permalink to “第9章、结构体与方法——面向对象的Go式实现”">​</a></h2><ol><li>结构体的定义与字段组织</li><li>结构体的零值与初始化方式</li><li>匿名字段与结构体嵌入</li><li>组合优于继承：Go的复用哲学</li><li>方法的定义与接收者类型选择</li><li>值接收者与指针接收者的区别</li><li>方法集与接口实现的关系</li><li>结构体标签（struct tag）的使用</li></ol><h1 id="第10章、接口与多态——go语言的抽象之美" tabindex="-1">第10章、接口与多态——Go语言的抽象之美 <a class="header-anchor" href="#第10章、接口与多态——go语言的抽象之美" aria-label="Permalink to “第10章、接口与多态——Go语言的抽象之美”">​</a></h1><p>一、接口的定义与隐式实现机制 二、空接口interface{}与泛型替代 三、类型断言与类型安全检查 四、类型选择（type switch）的使用 五、接口的组合与扩展性设计 六、鸭子类型与Go的多态实现 七、error接口的设计哲学 八、接口在大型项目中的分层应</p><h1 id="第11章、错误处理与异常机制——构建健壮程序" tabindex="-1">第11章、错误处理与异常机制——构建健壮程序 <a class="header-anchor" href="#第11章、错误处理与异常机制——构建健壮程序" aria-label="Permalink to “第11章、错误处理与异常机制——构建健壮程序”">​</a></h1><p>一、error接口与错误处理惯例 二、自定义错误类型与错误包装 三、使用fmt.Errorf与%w格式化 四、defer语句的执行时机与用途 五、panic与recover的异常恢复机制 六、defer、panic、recover协同使用 七、错误日志记录与上下文传递</p><h1 id="第12章、并发编程基石——goroutine与channel" tabindex="-1">第12章、并发编程基石——goroutine与channel <a class="header-anchor" href="#第12章、并发编程基石——goroutine与channel" aria-label="Permalink to “第12章、并发编程基石——goroutine与channel”">​</a></h1><p>一、goroutine：轻量级线程模型 二、Go调度器与GMP模型简介 三、channel的创建与基本操作 四、无缓冲channel与同步通信 五、有缓冲channel与异步解耦 六、单向channel与接口约束 七、关闭channel与迭代处理 八、并发安全与数据竞争检测</p>',25)])])}const m=i(r,[["render",n]]);export{b as __pageData,m as default};
